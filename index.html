
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>VibeSand - Ultimate GPU Playground</title>
      <style>
         :root {
         --base-padding: 16px;
         --accent-color: #00d4ff;
         --accent-glow: rgba(0, 212, 255, 0.3);
         --glass-bg: rgba(15, 20, 30, 0.65);
         --glass-border: rgba(255, 255, 255, 0.12);
         --text-primary: #ffffff;
         --text-secondary: #a8b4c0;
         --text-muted: #6b7785;
         --border-radius: 12px;
         --border-radius-sm: 8px;
         --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
         }
         
         * { box-sizing: border-box; }
         
         html, body { 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: var(--text-primary);
            font-size: 14px;
         }
         
         #canvas-container { 
            width: 100%; 
            height: 100%; 
            display: block; 
            position: relative; 
         }
         
         canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            background-color: #0d0d1a; 
            cursor: crosshair; 
         }
         
         /* Frosted Glass Panel Base */
         .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
         }
         
         /* Control Panel - Responsive Layout */
         #controlPanel {
            position: fixed;
            z-index: 100;
            transition: var(--transition);
            padding: 20px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
         }
         
         #controlPanel::-webkit-scrollbar {
            width: 6px;
         }
         
         #controlPanel::-webkit-scrollbar-track {
            background: transparent;
         }
         
         #controlPanel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
         }
         
         #controlPanel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
         }
         
         /* Landscape: Sidebar on left */
         @media (orientation: landscape) {
            #controlPanel {
               top: 16px;
               left: 16px;
               width: 280px;
               max-height: calc(100vh - 32px);
            }
         }
         
         /* Portrait: Bottom bar */
         @media (orientation: portrait) {
            #controlPanel {
               bottom: 16px;
               left: 16px;
               right: 16px;
               width: auto;
               max-height: 45vh;
            }
         }
         
         /* Panel Header */
         .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
         }
         
         .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
         }
         
         .stats-display {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--text-secondary);
         }
         
         .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
         }
         
         .stat-label {
            color: var(--text-muted);
         }
         
         /* Control Sections */
         .control-section {
            margin-bottom: 20px;
         }
         
         .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 10px;
         }
         
         /* Button Groups */
         .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
         }
         
         .glass-button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 8px 14px;
            border-radius: var(--border-radius-sm);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            flex: 1;
            min-width: fit-content;
         }
         
         .glass-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
         }
         
         .glass-button.active {
            background: linear-gradient(135deg, var(--accent-color), #0099cc);
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         .glass-button.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px var(--accent-glow);
         }
         
         /* Slider Controls */
         .slider-control {
            margin-bottom: 14px;
         }
         
         .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            color: var(--text-secondary);
         }
         
         .slider-value {
            font-weight: 600;
            color: var(--accent-color);
            font-size: 12px;
         }
         
         input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
         }
         
         input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 2px 8px var(--accent-glow);
            transition: var(--transition);
         }
         
         input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px var(--accent-glow);
            transition: var(--transition);
         }
         
         input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px var(--accent-glow);
         }
         
         /* Select Dropdown */
         select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: var(--transition);
         }
         
         select:hover, select:focus {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--accent-color);
            outline: none;
         }
         
         /* Checkbox */
         .checkbox-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
            cursor: pointer;
            user-select: none;
         }
         
         .checkbox-control input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-color);
         }
         
         .checkbox-control label {
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            flex: 1;
         }
         
         /* Info Toggle Button */
         #infoToggleButton {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 101;
            padding: 10px 16px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
         }
         
         #infoToggleButton:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
         }
         
         /* Info Panel */
         #descriptionArea {
            position: fixed;
            top: 60px;
            right: 16px;
            width: min(400px, calc(100vw - 32px));
            max-height: calc(100vh - 92px);
            padding: 24px;
            z-index: 100;
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0s;
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
         }
         
         #descriptionArea::-webkit-scrollbar {
            width: 6px;
         }
         
         #descriptionArea::-webkit-scrollbar-track {
            background: transparent;
         }
         
         #descriptionArea::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
         }
         
         #descriptionArea.hidden {
            opacity: 0;
            transform: translateY(-20px);
            visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0.3s;
         }
         
         #descriptionArea h2 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-color);
         }
         
         #descriptionArea h4 {
            margin: 16px 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
         }
         
         #descriptionArea p {
            margin: 0 0 12px 0;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
         }
         
         #descriptionArea ul {
            margin: 0 0 12px 0;
            padding-left: 20px;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
         }
         
         #descriptionArea li {
            margin-bottom: 6px;
         }
         
         #descriptionArea code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: var(--accent-color);
         }
         
         #descriptionArea a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
         }
         
         #descriptionArea a:hover {
            text-decoration: underline;
         }
         
         .credits {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--glass-border);
            font-size: 12px;
            text-align: center;
            color: var(--text-muted);
         }
         
         /* Instructions */
         #instructions {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            font-size: 12px;
            color: var(--text-secondary);
            z-index: 40;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
         }
         
         @media (orientation: portrait) {
            #instructions {
               bottom: auto;
               top: 16px;
               left: 50%;
            }
         }
         
         /* First Person HUD */
         #firstPersonHUD {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 60;
         }
         
         #firstPersonHUD::before,
         #firstPersonHUD::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
         }
         
         #firstPersonHUD::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
         }
         
         #firstPersonHUD::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
         }
         
         /* Responsive adjustments */
         @media (max-width: 768px) {
            #controlPanel {
               padding: 16px;
            }
            
            .button-group {
               gap: 6px;
            }
            
            .glass-button {
               padding: 7px 12px;
               font-size: 12px;
            }
            
            @media (orientation: landscape) {
               #controlPanel {
                  width: 240px;
               }
            }
         }
         
         @media (max-width: 480px) {
            #descriptionArea {
               width: calc(100vw - 32px);
            }
            
            @media (orientation: portrait) {
               #controlPanel {
                  max-height: 50vh;
               }
            }
         }
      </style>
   </head>
   <body>
      <button id="infoToggleButton">ℹ️ Info</button>
      <div id="descriptionArea" class="glass-panel">
         <h2>VibeSand 0.2</h2>
         <p style="font-size: 12px; margin-top: -4px; margin-bottom: 16px;">GPU-Powered Voxel Playground</p>
         <p style="color: var(--accent-color); font-weight: 600; margin-bottom: 12px;">💡 Performance Tip: Adjust Render Scale if slow</p>
         <p><strong>VibeSand</strong> is a WebGPU voxel engine. It simulates millions of particles entirely on your GPU. Watch sand form natural piles, water fill basins and flow over edges, and sculpt the world in real time, all illuminated by dynamic lights.</p>
         <h4>Things to Try:</h4>
         <ul style="font-size: 0.9em;">
            <li>Sculpt a stone bowl or pyramid; observe how sand tumbles down slopes and water cascades, lit by the falling lights. Water voxels now have a subtle internal shimmer and appear more luminous.</li>
            <li>Create stair-step patterns; watch particles navigate edges, sliding and collecting in corners.</li>
            <li>Drop blobs of sand into water; see how particles sift, settle, and displace the water.</li>
            <li>Use the "Destroy" tool to punch a hole in the floor beneath water or sand; watch it drain.</li>
            <li>Crank up the <code>Sim Steps</code> slider, then use the Water tool to create fast-moving waves.</li>
            <li>Experiment with the <code>Max Ray Steps</code> slider (capped at 384) to see how it affects visuals and performance.</li>
            <li>Build dams; see how water pressure affects flow when you release it.</li>
         </ul>
         <h4>Key Features</h4>
         <ul style="font-size: 12px;">
            <li><strong>Dynamic Particles & Lighting:</strong> Sand slides naturally, water flows with enhanced shimmer, illuminated by colorful point lights</li>
            <li><strong>Full GPU Pipeline:</strong> Physics, targeting, lighting, and rendering all run on GPU shaders</li>
            <li><strong>Interactive Tools:</strong> Sculpt with sand, stone, water, or erase with clear visual previews</li>
            <li><strong>Single-Pass Rendering:</strong> DDA raymarching renders everything in one go</li>
         </ul>
         <h4>Controls</h4>
         <ul style="font-size: 12px;">
            <li><strong>Orbital Mode:</strong> Right-click to orbit, Middle/Space+Left to pan, Wheel to zoom</li>
            <li><strong>First Person Mode:</strong> WASD to move, Space to move up, Mouse to look (Noclip mode - collision via player voxel)</li>
         </ul>
         <p class="credits">
            Vibecoded <span id="currentDate"></span> by
            <a href="https://tront.xyz" target="_blank">Trent Sterling</a> & AI
         </p>
      </div>
      
      <div id="controlPanel" class="glass-panel">
         <div class="panel-header">
            <div class="panel-title">
               🎮 VibeSand
            </div>
            <div class="stats-display">
               <div class="stat-item">
                  <span class="stat-label">FPS:</span>
                  <span id="fps">0</span>
               </div>
               <div class="stat-item">
                  <span class="stat-label">Voxels:</span>
                  <span id="voxelCount">0</span>
               </div>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">World</div>
            <div class="button-group">
               <button id="worldTypeTerrain" class="glass-button active">🏔️ Terrain</button>
               <button id="worldTypeFlat" class="glass-button">⬜ Flat</button>
            </div>
            <div class="button-group" style="margin-top: 8px;">
               <button id="resetSimButton" class="glass-button" style="flex: 2;">🔄 Reset</button>
               <button id="clearLooseButton" class="glass-button" style="flex: 1;">🧹 Clear</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Tool</div>
            <div class="button-group">
               <button id="toolPaintSand" class="glass-button active">🏖️ Sand</button>
               <button id="toolPaintStone" class="glass-button">🪨 Stone</button>
            </div>
            <div class="button-group" style="margin-top: 8px;">
               <button id="toolPaintWater" class="glass-button">💧 Water</button>
               <button id="toolDestroy" class="glass-button">💥 Destroy</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Brush</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Size</span>
                  <span class="slider-value" id="brushSizeValue">10.5</span>
               </div>
               <input type="range" id="brushSize" min="1" max="25" step="0.5" value="10.5">
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Simulation</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Steps/Frame</span>
                  <span class="slider-value" id="simStepsValue">1</span>
               </div>
               <input type="range" id="simSteps" min="0" max="25" step="1" value="1">
            </div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Sun Speed</span>
                  <span class="slider-value" id="sunSpeedValue">0.0200</span>
               </div>
               <input type="range" id="sunSpeed" min="0" max="0.02" step="0.0001" value="0.02">
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Rendering</div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Max Ray Steps</span>
                  <span class="slider-value" id="maxRayStepsValue">384</span>
               </div>
               <input type="range" id="maxRaySteps" min="64" max="384" step="32" value="384">
            </div>
            <div class="slider-control">
               <div class="slider-label">
                  <span>Render Scale</span>
                  <span class="slider-value" id="resolutionScaleValue">100%</span>
               </div>
               <select id="resolutionScale">
                  <option value="1.0">Native (100%)</option>
                  <option value="0.75">High (75%)</option>
                  <option value="0.5">Medium (50%)</option>
                  <option value="0.25">Low (25%)</option>
               </select>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Camera</div>
            <div class="button-group">
               <button id="cameraModeOrbital" class="glass-button active">🔄 Orbital</button>
               <button id="cameraModeFirstPerson" class="glass-button">🎮 FPS</button>
            </div>
         </div>
         
         <div class="control-section">
            <div class="section-title">Options</div>
            <div class="checkbox-control">
               <input type="checkbox" id="continuousPaintToggle" checked>
               <label for="continuousPaintToggle">Continuous Paint</label>
            </div>
            <div class="checkbox-control">
               <input type="checkbox" id="targetFarFaceToggle" checked>
               <label for="targetFarFaceToggle">Target Far Face (on air)</label>
            </div>
         </div>
      </div>
      
      <div id="firstPersonHUD" style="display: none;"></div>
      <div id="canvas-container">
         <canvas id="webgpu-canvas"></canvas>
      </div>
      <div id="instructions">
         <span id="orbitalInstructions">Right-click to orbit • Middle-mouse/Space+Left to pan</span>
         <span id="firstPersonInstructions" style="display:none;">WASD to move • Space to jump • Mouse to look • Click to lock cursor</span>
      </div>
      <script type="module">
         // ==================================================
         // 📚 可调参数文档 | Adjustable Parameters Documentation
         // ==================================================
         /*
         
         ⚙️ 核心参数 | Core Parameters
         ================================
         
         1. VOXEL_GRID_SIZE (体素网格大小)
            位置: 第769行附近
            当前值: 128
            范围: 32, 64, 128, 256 (必须是2的幂次方)
            效果: 
            - 更大 → 更多细节，更大的世界，但性能显著降低
            - 更小 → 更好的性能，但世界更小，细节更少
            注意: 修改后需要重新生成世界
         
         2. NUM_LIGHTS (光源数量)
            位置: 第786行附近
            当前值: 32
            范围: 8-64
            效果:
            - 更多 → 更丰富的照明效果，但降低性能
            - 更少 → 提高性能，但照明效果较少
            建议: 16-32之间平衡性能和视觉效果
         
         3. PAN_SENSITIVITY (相机平移灵敏度)
            位置: 第782行附近
            当前值: 0.1
            范围: 0.05-0.5
            效果:
            - 更大 → 鼠标拖动时相机移动更快
            - 更小 → 相机移动更慢，更精确控制
         
         
         💡 光源参数 | Light Parameters
         ================================
         
         4. lights[i].radius (光源半径)
            位置: 第798行附近
            当前值: 20.0 + Math.random() * 15 (20-35)
            范围: 10-50
            效果:
            - 更大 → 光照覆盖更大的区域
            - 更小 → 光照更集中
            示例修改: radius: 30.0 (固定半径30)
         
         5. lights[i].velocity (光源下落速度)
            位置: 第800行附近
            当前值: -20.0 - Math.random() * 20.0 (-20到-40)
            范围: -60 到 -5
            效果:
            - 更负 → 光源下落更快
            - 接近0 → 光源下落更慢或悬浮
            示例修改: velocity: -10.0 (慢速下落)
         
         6. lights[i].color (光源颜色)
            位置: 第795行附近
            当前: HSVtoRGB(Math.random(), 0.9, 1.0) (随机彩色)
            效果:
            - HSVtoRGB(0, 0.9, 1.0) → 纯红色光源
            - HSVtoRGB(0.33, 0.9, 1.0) → 纯绿色光源
            - HSVtoRGB(0.66, 0.9, 1.0) → 纯蓝色光源
            - HSVtoRGB(0, 0, 1.0) → 白色光源
            示例: 所有光源都是暖黄色
            color: HSVtoRGB(0.15, 0.8, 1.0)
         
         
         ☀️ 环境参数 | Environment Parameters
         ================================
         
         7. sunSpeed (太阳旋转速度)
            位置: UI控制，第812行附近
            当前值: 0.02
            范围: 0-0.05
            效果:
            - 更大 → 日夜循环更快
            - 0 → 太阳静止不动
            - 负值 → 太阳反向旋转
         
         8. sunAngle (初始太阳角度)
            位置: 第801行附近
            当前值: Math.PI / 4
            范围: 0 到 2*Math.PI
            效果:
            - 0 → 太阳在东方
            - Math.PI/2 → 太阳在南方
            - Math.PI → 太阳在西方
            - 3*Math.PI/2 → 太阳在北方
         
         
         🎨 渲染参数 | Rendering Parameters
         ================================
         
         9. maxRaySteps (最大光线追踪步数)
            位置: UI控制，第833行附近
            当前值: 384
            范围: 64-512
            效果:
            - 更多 → 可以看得更远，但性能降低
            - 更少 → 提高性能，但远处物体可能消失
            建议: 低端GPU使用128，高端GPU使用384
         
         10. resolutionScale (渲染分辨率缩放)
             位置: UI控制，第824行附近
             当前值: 1.0 (100%)
             范围: 0.25-1.0 (25%-100%)
             效果:
             - 1.0 → 原生分辨率，最佳画质
             - 0.5 → 50%分辨率，性能提升4倍
             - 0.25 → 25%分辨率，性能提升16倍
             注意: 降低分辨率会使画面模糊
         
         11. clearValue (背景颜色)
             位置: 第1934行附近
             当前值: [0.1, 0.1, 0.2, 1.0] (深蓝色)
             格式: [红, 绿, 蓝, 透明度] (0-1范围)
             效果示例:
             - [0, 0, 0, 1] → 黑色背景
             - [1, 1, 1, 1] → 白色背景
             - [0.5, 0, 0, 1] → 深红色背景
         
         
         ⚡ 物理参数 | Physics Parameters
         ================================
         
         12. simSteps (每帧模拟步数)
             位置: UI控制，第830行附近
             当前值: 1
             范围: 0-25
             效果:
             - 0 → 暂停物理模拟
             - 1 → 正常速度
             - 5+ → 快速物理模拟
             注意: 更多步数会降低帧率
         
         13. brushSize (画笔大小)
             位置: UI控制，第815行附近
             当前值: 10.5
             范围: 1-25
             效果:
             - 更大 → 绘制更大的区域
             - 更小 → 更精细的绘制
         
         
         📷 相机参数 | Camera Parameters
         ================================
         
         14. camera.radius (轨道相机距离)
             位置: 第835行附近
             当前值: VOXEL_GRID_SIZE * 1.8
             范围: 50-500
             效果:
             - 更大 → 相机离场景更远
             - 更小 → 相机离场景更近
         
         15. camera.target (相机目标点)
             位置: 第838行附近
             当前值: [VOXEL_GRID_SIZE/2, 30, VOXEL_GRID_SIZE/2]
             效果: 相机围绕这个点旋转
             示例: [64, 50, 64] (更高的观察点)
         
         16. firstPersonCamera.speed (第一人称移动速度)
             位置: 第823行附近
             当前值: 20.0
             范围: 5.0-50.0
             效果:
             - 更大 → 移动更快
             - 更小 → 移动更慢，更精确控制
         
         
         🎨 视觉效果参数 | Visual Effect Parameters
         =========================================
         
         17. 水的颜色 (Water Color)
             位置: renderShaderCode第1279行附近
             当前值: vec3(0.15, 0.45, 0.85) (蓝色)
             效果:
             - vec3(0.1, 0.8, 0.8) → 青色水
             - vec3(0.2, 0.2, 0.9) → 深蓝色水
             - vec3(0.5, 0.1, 0.6) → 紫色水(幻想效果)
         
         18. 沙子颜色 (Sand Color)
             位置: renderShaderCode第1277行附近
             当前值: vec3(0.8, 0.7, 0.4) (黄色)
             效果:
             - vec3(1.0, 0.9, 0.6) → 亮黄色沙子
             - vec3(0.6, 0.4, 0.2) → 棕色沙子
             - vec3(0.9, 0.3, 0.3) → 红色沙子(火星效果)
         
         19. 石头颜色 (Stone Color)
             位置: renderShaderCode第1275行附近
             当前值: vec3(0.45) (灰色)
             效果:
             - vec3(0.3) → 更深的灰色
             - vec3(0.6) → 更浅的灰色
             - vec3(0.4, 0.5, 0.4) → 绿灰色(苔藓石头)
         
         
         ⚙️ 高级效果参数 | Advanced Effect Parameters
         =============================================
         
         20. 云层密度 (Cloud Density)
             位置: renderShaderCode第1372行附近
             当前: smoothstep(0.4, 0.7, cloud_density)
             效果:
             - smoothstep(0.3, 0.6, ...) → 更多云
             - smoothstep(0.5, 0.8, ...) → 更少云
         
         21. 云层速度 (Cloud Speed)
             位置: renderShaderCode第1363行附近
             当前: time * 0.02 和 time * 0.05
             效果:
             - 增加系数 → 云移动更快
             - 减少系数 → 云移动更慢
         
         22. 太阳大小和强度 (Sun Size and Intensity)
             位置: renderShaderCode第1353-1356行附近
             当前: pow(..., 128.0) (主盘), pow(..., 8.0) (光晕)
             效果:
             - 增加指数 → 太阳更小更亮
             - 减少指数 → 太阳更大更柔和
         
         
         💡 实用建议 | Practical Tips
         ============================
         
         性能优化组合 (Performance Optimization):
         - VOXEL_GRID_SIZE: 64
         - NUM_LIGHTS: 16
         - maxRaySteps: 128
         - resolutionScale: 0.5
         - simSteps: 1
         
         视觉质量组合 (Visual Quality):
         - VOXEL_GRID_SIZE: 128
         - NUM_LIGHTS: 32
         - maxRaySteps: 384
         - resolutionScale: 1.0
         - simSteps: 2
         
         创意实验组合 (Creative Experiments):
         1. 彩虹雨效果: 保持light color随机，增加NUM_LIGHTS到48
         2. 月光效果: sunSpeed: 0, 所有lights为蓝白色
         3. 火星场景: 沙子改为红色，天空改为红褐色
         4. 水下世界: 水改为绿色，增加水的亮度参数
         
         */
         
         // --- Start of UI elements that can be initialized without WebGPU ---
         const infoToggleButtonElement = document.getElementById('infoToggleButton');
         const descriptionAreaElement = document.getElementById('descriptionArea');
         if (infoToggleButtonElement && descriptionAreaElement) {
             // Start with info panel hidden
             descriptionAreaElement.classList.add('hidden');
             infoToggleButtonElement.textContent = '📖 Show Info';
             
             infoToggleButtonElement.onclick = () => {
                 descriptionAreaElement.classList.toggle('hidden');
                 infoToggleButtonElement.textContent = descriptionAreaElement.classList.contains('hidden') ? '📖 Show Info' : '✖️ Hide Info';
             };
         }

         const currentDateEl = document.getElementById('currentDate');
         if (currentDateEl) {
            try {
                currentDateEl.textContent = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            } catch (e) {
                console.warn("Could not set date:", e);
                currentDateEl.textContent = "Today"; // Fallback
            }
         }

         function displayErrorAndStop(title, message) {
             console.error(`VibeSand Error: ${title} - ${message}`);
             document.body.innerHTML = `
                 <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1a1a2e; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: sans-serif; padding: 20px; box-sizing: border-box; text-align: center; z-index: 200;">
                     <h1 style="color: var(--highlight-color, #ffae5a); margin-bottom: 20px;">${title}</h1>
                     <p style="font-size: 1.1em; max-width: 600px; line-height: 1.6;">${message}</p>
                     <p style="margin-top: 25px; font-size: 0.9em;">Please ensure your browser (e.g., Chrome, Edge) is up-to-date and WebGPU is enabled. You can check <a href="https://webgpureport.org" target="_blank" style="color: var(--accent-color, #00aaff); text-decoration: underline;">WebGPUReport.org</a> for your browser's status.</p>
                     <p style="margin-top: 15px; font-size: 0.9em;">On systems with multiple GPUs (like laptops), make sure your browser is using the dedicated (high-performance) graphics card for WebGPU.</p>
                 </div>`;
             throw new Error(`VibeSand HALTED: ${title}`); // Stop further script execution
         }
         // --- End of non-WebGPU UI ---

         // ==================================================
         // WebGPU 初始化和主函数 | WebGPU Initialization and Main Function
         // ==================================================
         async function initAndRun() {
             // 步骤1: 获取HTML画布元素 | Step 1: Get the HTML canvas element
             // 画布是我们绘制3D图形的地方 | The canvas is where we'll draw our 3D graphics
             const canvas = document.getElementById('webgpu-canvas');
             if (!canvas) {
                 displayErrorAndStop("Initialization Error", "The canvas element (#webgpu-canvas) was not found in the HTML. The page structure might be broken.");
                 return; // Will not be reached
             }

             // 步骤2: 检查浏览器是否支持WebGPU | Step 2: Check if browser supports WebGPU
             // navigator.gpu 是浏览器提供的WebGPU API入口 | navigator.gpu is the browser's WebGPU API entry point
             if (!navigator.gpu) {
                 displayErrorAndStop("WebGPU Not Supported", "Your browser does not support WebGPU, or it is disabled. VibeSand requires WebGPU to run.");
                 return;
             }

             // 步骤3: 请求GPU适配器 (Adapter) | Step 3: Request GPU Adapter
             // Adapter代表系统中的一个物理GPU | Adapter represents a physical GPU in the system
             // 在有多个GPU的系统中，浏览器会选择最合适的一个 | On systems with multiple GPUs, browser picks the best one
             let adapter;
             try {
                 adapter = await navigator.gpu.requestAdapter();
             } catch (e) {
                 displayErrorAndStop("WebGPU Adapter Error", `Failed to request a WebGPU adapter. This could be due to outdated drivers, or your browser/OS configuration. Error: ${e.message || e}`);
                 return;
             }

             if (!adapter) {
                 displayErrorAndStop("No WebGPU Adapter Found", "No suitable GPU was found for WebGPU. Your GPU might not support WebGPU, it might be disabled in your browser settings, or your graphics drivers need an update.");
                 return;
             }

             // 步骤4: 从适配器请求GPU设备 (Device) | Step 4: Request GPU Device from Adapter
             // Device是我们实际与GPU通信的对象 | Device is the object we actually use to communicate with the GPU
             // 一个设备可以创建缓冲区、管线、纹理等GPU资源 | A device can create buffers, pipelines, textures, and other GPU resources
             let device;
             try {
                 device = await adapter.requestDevice();
             } catch (e) {
                 displayErrorAndStop("WebGPU Device Error", `Failed to obtain a WebGPU device from the adapter. This can happen if the GPU is not fully compatible, due to driver issues, or if the system is under heavy load. Error: ${e.message || e}`);
                 return;
             }

             if (!device) {
                 displayErrorAndStop("WebGPU Device Error", "Failed to obtain a WebGPU device (requestDevice returned null/undefined without rejecting). Please check the browser console for more details.");
                 return;
             }

             // 步骤5: 配置画布的WebGPU上下文 | Step 5: Configure canvas WebGPU context
             // context是画布和GPU之间的桥梁 | context is the bridge between canvas and GPU
             const context = canvas.getContext('webgpu');
             // 获取首选的像素格式 (通常是 'bgra8unorm' 或 'rgba8unorm')
             // Get preferred pixel format (usually 'bgra8unorm' or 'rgba8unorm')
             const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
             // 配置上下文：指定使用哪个设备、像素格式、透明度模式
             // Configure context: specify which device to use, pixel format, alpha mode
             context.configure({ device, format: presentationFormat, alphaMode: 'premultiplied' });

             // ==================================================
             // 🎨 可调参数区域 | Adjustable Parameters Section
             // ==================================================
             // 这些参数可以修改以获得不同的视觉效果 | These parameters can be modified for different visual effects
             
             // ⚙️ 体素网格大小 | Voxel Grid Size
             // 范围: 32-256 (必须是2的幂次方，如32, 64, 128, 256)
             // Range: 32-256 (must be power of 2, like 32, 64, 128, 256)
             // 更大的网格 = 更多细节，但性能更低 | Larger grid = more detail, but lower performance
             // 更小的网格 = 更好性能，但细节较少 | Smaller grid = better performance, but less detail
             const VOXEL_GRID_SIZE = 128;
             const NUM_VOXELS = VOXEL_GRID_SIZE ** 3;
             document.getElementById('voxelCount').textContent = NUM_VOXELS.toLocaleString();
             
             // 🖱️ 相机平移灵敏度 | Camera Pan Sensitivity  
             // 范围: 0.05-0.5 | Range: 0.05-0.5
             // 更大的值 = 平移更快 | Larger value = faster panning
             const PAN_SENSITIVITY = 0.1;
             
             // 🧍 第一人称玩家物理参数 | First-Person Player Physics Parameters
             const PLAYER_HEIGHT = 1.8;      // 玩家高度(体素单位) | Player height in voxel units
             const PLAYER_RADIUS = 0.4;      // 玩家碰撞半径 | Player collision radius
             const PLAYER_EYE_HEIGHT = 1.6;  // 眼睛高度 | Eye height from feet

             // 🛠️ 工具类型常量 | Tool Type Constants
             // 这些常量定义了不同的绘制工具 | These constants define different painting tools
             const TOOL_PAINT_SAND = 0;   // 沙子工具 | Sand tool
             const TOOL_PAINT_STONE = 1;  // 石头工具 | Stone tool
             const TOOL_DESTROY = 2;       // 销毁/擦除工具 | Destroy/erase tool
             const TOOL_PAINT_WATER = 3;   // 水工具 | Water tool

             // ==================================================
             // 💡 动态光源系统 | Dynamic Light System
             // ==================================================
             // 💡 光源数量 | Number of Lights
             // 范围: 8-64 | Range: 8-64
             // 更多光源 = 更丰富的照明，但性能更低 | More lights = richer lighting, but lower performance
             // 建议: 保持在16-32之间以获得良好的性能/质量平衡 | Recommended: keep between 16-32 for good performance/quality balance
             const NUM_LIGHTS = 32;
             const lights = [];
             
             // HSV转RGB的辅助函数 | HSV to RGB helper function
             // 用于生成彩色光源 | Used to generate colorful lights
             function HSVtoRGB(h, s, v) {
                 let r, g, b, i, f, p, q, t;
                 i = Math.floor(h * 6); f = h * 6 - i;
                 p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);
                 switch (i % 6) {
                     case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
                     case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
                     case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
                 }
                 return [r, g, b];
             }
             
             // 初始化所有光源 | Initialize all lights
             for (let i = 0; i < NUM_LIGHTS; i++) {
                 lights.push({
                     // 🎨 光源位置 | Light position (可以修改初始位置 | can modify initial position)
                     position: [Math.random() * VOXEL_GRID_SIZE, Math.random() * VOXEL_GRID_SIZE, Math.random() * VOXEL_GRID_SIZE],
                     // 🌈 光源颜色 (HSV色轮随机选择) | Light color (randomly selected from HSV color wheel)
                     // 修改 Math.random() 为固定值(0-1)可以得到特定颜色的光源 | Change Math.random() to fixed value (0-1) for specific color
                     // 例如 0=红色, 0.33=绿色, 0.66=蓝色 | e.g., 0=red, 0.33=green, 0.66=blue
                     color: HSVtoRGB(Math.random(), 0.9, 1.0),
                     // 🔦 光源半径 | Light radius
                     // 范围: 10-50 | Range: 10-50  
                     // 修改这里可以改变光照范围 | Modify here to change lighting range
                     radius: 20.0 + Math.random() * 15,
                     // ⬇️ 光源下落速度 (负值表示向下) | Light falling velocity (negative = downward)
                     // 范围: -60 到 -10 | Range: -60 to -10
                     // 更负的值 = 下落更快 | More negative = falls faster
                     velocity: -20.0 - Math.random() * 20.0,
                 });
             }

             // ==================================================
             // 🎮 应用状态和配置 | Application State and Configuration
             // ==================================================
             
             // ☀️ 太阳角度 (用于日夜循环) | Sun angle (for day/night cycle)
             // 范围: 0 到 2π | Range: 0 to 2π
             let sunAngle = Math.PI / 4;
             
             // 当前选中的工具 | Currently selected tool
             let currentTool = TOOL_PAINT_SAND;
             
             // 地形类型: 1=山地地形, 0=平坦地形 | Terrain type: 1=mountainous terrain, 0=flat terrain
             let currentTerrainType = 1;
             
             // UI控制参数 | UI control parameters
             let uiControls = {
                 // ☀️ 太阳旋转速度 | Sun rotation speed
                 // 范围: 0-0.05 | Range: 0-0.05
                 // 更大的值 = 日夜循环更快 | Larger value = faster day/night cycle
                 sunSpeed: 0.02,
                 
                 // 🖌️ 画笔大小 | Brush size
                 // 范围: 1-25 | Range: 1-25
                 brushSize: 10.5,
                 
                 // 是否连续绘制 | Whether to paint continuously
                 continuousPaint: true,
                 
                 // 当光线打到空气时是否瞄准远面 | Whether to target far face when ray hits air
                 targetFarFaceOnAirHit: true,
                 
                 // 📐 渲染分辨率缩放 | Render resolution scale
                 // 范围: 0.25-1.0 (25%-100%) | Range: 0.25-1.0 (25%-100%)
                 // 降低可以提高性能 | Lower to improve performance
                 resolutionScale: 1.0,
                 
                 // 🔄 每帧模拟步数 | Simulation steps per frame
                 // 范围: 0-25 | Range: 0-25
                 // 更多步数 = 更快的物理模拟，但性能更低 | More steps = faster physics simulation, but lower performance
                 simSteps: 1,
                 
                 // 🔍 最大光线追踪步数 | Max ray marching steps
                 // 范围: 64-384 | Range: 64-384
                 // 更多步数 = 更远的渲染距离，但性能更低 | More steps = further render distance, but lower performance
                 maxRaySteps: 384,
             };
             
             // 📷 轨道相机参数 | Orbital camera parameters
             let camera = {
                 // 水平旋转角度 | Horizontal rotation angle
                 alpha: -0.5,
                 // 垂直旋转角度 | Vertical rotation angle
                 beta: 0.3,
                 // 相机距离目标点的距离 | Camera distance from target
                 radius: VOXEL_GRID_SIZE * 1.8,
                 // 相机看向的目标点 | Camera target point
                 target: [VOXEL_GRID_SIZE / 2, 30, VOXEL_GRID_SIZE / 2],
             };
             let mouseState = {
                 buttons: [false, false, false], x: 0, y: 0, lastX: 0, lastY: 0, isPainting: false, isOrbiting: false, isPanning: false, hasFiredSingleShot: false,
             };
             let spacebarDown = false;
             let frameCount = 0;
             let isPreviewVisible = true;
             let currentCamX=0, currentCamY=0, currentCamZ=0;
             let currentForward=[0,0,1], currentRight=[1,0,0], currentUp=[0,1,0];
             let cameraMode = 'orbital'; // 'orbital' or 'firstperson'
             let firstPersonCamera = {
                position: [VOXEL_GRID_SIZE / 2, VOXEL_GRID_SIZE - 10, VOXEL_GRID_SIZE / 2], // Spawn high above terrain
                yaw: -Math.PI / 2, // Looking towards +X initially
                pitch: 0,
                velocity: [0, 0, 0],
                speed: 20.0,
                jumpVelocity: 8.0,
                gravity: -20.0,
                isGrounded: false,
                height: 1.8,
             };
             let keyState = {
                w: false, a: false, s: false, d: false, space: false, shift: false,
             };

             // ==================================================
             // 📜 WGSL着色器代码 - 公共部分 | WGSL Shader Code - Common Section
             // ==================================================
             // WGSL (WebGPU Shading Language) 是WebGPU使用的着色器语言
             // WGSL (WebGPU Shading Language) is the shader language used by WebGPU
             // 着色器在GPU上运行，速度非常快 | Shaders run on the GPU and are very fast
             
             const commonShaderCode = `
                 // 📦 体素数据结构 | Voxel Data Structure
                 // 每个体素用一个32位无符号整数存储 | Each voxel is stored as a 32-bit unsigned integer
                 // 这个整数包含: 类型、变体、更新标志、RGB光照信息 | This integer contains: type, variant, update flag, RGB lighting
                 struct VoxelData {
                     data: atomic<u32>,  // atomic类型允许多个线程同时安全访问 | atomic type allows safe concurrent access
                 };

                 // 💡 点光源结构 | Point Light Structure
                 struct PointLight {
                     pos: vec3<f32>,      // 光源3D位置 | Light 3D position
                     radius: f32,         // 光源影响半径 | Light influence radius
                     color: vec3<f32>,    // 光源RGB颜色 | Light RGB color
                     intensity: f32,      // 光源强度 | Light intensity
                 };
                 
                 // 🌍 场景全局数据 | Scene Global Data
                 struct SceneUniforms {
                     lights: array<PointLight, ${NUM_LIGHTS}>,  // 所有光源的数组 | Array of all lights
                     light_count: u32,                           // 光源数量 | Number of lights
                 };

                 // 📷 渲染通道统一变量 | Render Pass Uniforms
                 // 这些变量在每一帧都会更新，传递相机和渲染设置到着色器
                 // These variables update every frame, passing camera and render settings to shaders
                 struct RenderPassUniforms {
                     camera_position: vec3<f32>,    // 相机位置 | Camera position
                     camera_zoom: f32,               // 相机缩放/FOV | Camera zoom/FOV
                     camera_right: vec3<f32>,        // 相机右向量 | Camera right vector
                     _padr: f32,                     // 填充对齐 | Padding for alignment
                     camera_up: vec3<f32>,           // 相机上向量 | Camera up vector
                     _padu: f32,                     // 填充对齐 | Padding for alignment
                     camera_target_pos: vec3<f32>,   // 相机看向的目标点 | Camera target point
                     _padt: f32,                     // 填充对齐 | Padding for alignment
                     sun_direction: vec3<f32>,       // 太阳方向向量 | Sun direction vector
                     _pads: f32,                     // 填充对齐 | Padding for alignment
                     canvas_actual_dims: vec2<f32>,  // 画布实际像素尺寸 | Canvas actual pixel dimensions
                     max_ray_steps: u32,             // 光线追踪最大步数 | Ray marching max steps
                     _pad_mrs: u32,                  // 填充对齐 | Padding for alignment
                 };

                 // 🖥️ 计算通道统一变量 | Compute Pass Uniforms
                 // 用于物理模拟和交互的参数 | Parameters for physics simulation and interaction
                 struct ComputePassUniforms {
                     camera_position: vec3<f32>,     // 相机位置 | Camera position
                     camera_zoom: f32,               // 相机缩放 | Camera zoom
                     camera_right: vec3<f32>,        // 相机右向量 | Camera right vector
                     _padr2: f32,
                     camera_up: vec3<f32>,           // 相机上向量 | Camera up vector
                     _padu2: f32,
                     camera_target_pos: vec3<f32>,   // 相机目标 | Camera target
                     _padt2: f32,
                     mouse_pos: vec2<f32>,           // 鼠标位置 | Mouse position
                     canvas_dims: vec2<f32>,         // 画布尺寸 | Canvas dimensions
                     brush_size: f32,                // 画笔大小 | Brush size
                     is_painting: u32,               // 是否正在绘制 | Whether painting
                     tool_type: u32,                 // 工具类型 | Tool type
                     preview_active: u32,            // 预览是否激活 | Whether preview is active
                     target_far_face_on_air_hit: u32, // 目标选择模式 | Target selection mode
                     frame_num: u32,                 // 帧编号 | Frame number
                     max_ray_steps_compute: u32,     // 计算用的最大步数 | Max steps for compute
                     _pad_mrs_compute: u32,
                 };

                 // 🎯 目标输出结构 | Targeting Output Structure
                 // 用于存储光线追踪找到的目标位置 | Used to store target position found by ray tracing
                 struct TargetingOutput { 
                     aim_pos: vec4<f32>,  // 瞄准位置 | Aim position
                     hit: u32             // 是否命中 | Whether hit
                 };

                 // 🧱 体素类型常量 | Voxel Type Constants
                 // 这些常量定义了不同类型的体素 | These constants define different voxel types
                 const VOXEL_TYPE_AIR = 0u;      // 空气(透明) | Air (transparent)
                 const VOXEL_TYPE_STONE = 1u;    // 石头(固体) | Stone (solid)
                 const VOXEL_TYPE_SAND = 2u;     // 沙子(会下落) | Sand (falls)
                 const VOXEL_TYPE_WATER = 3u;    // 水(流动) | Water (flows)
                 const VOXEL_TYPE_PLAYER = 4u;   // 玩家(受物理影响) | Player (affected by physics)

                 // 🛠️ 工具类型常量 | Tool Type Constants
                 const TOOL_TYPE_SAND = 0u;
                 const TOOL_TYPE_STONE = 1u;
                 const TOOL_TYPE_DESTROY = 2u;
                 const TOOL_TYPE_WATER = 3u;

                 // 📏 网格尺寸 | Grid dimension
                 const GRID_DIM = ${VOXEL_GRID_SIZE}u;

                 // 🔢 位操作掩码和偏移 | Bit manipulation masks and shifts
                 // 用于将多个值打包到单个32位整数中 | Used to pack multiple values into a single 32-bit integer
                 // 这样可以节省GPU内存 | This saves GPU memory
                 const MASK_TYPE = 7u;           // 0b111 - 类型占用3位 | Type uses 3 bits
                 const SHIFT_TYPE = 0u;          // 类型从第0位开始 | Type starts at bit 0
                 const MASK_VARIANT = 7u;        // 0b111 - 变体占用3位 | Variant uses 3 bits
                 const SHIFT_VARIANT = 3u;       // 变体从第3位开始 | Variant starts at bit 3
                 const MASK_UPDATED = 1u;        // 0b1 - 更新标志占用1位 | Updated flag uses 1 bit
                 const SHIFT_UPDATED = 6u;       // 标志从第6位开始 | Flag starts at bit 6

                 const MASK_LIGHT = 255u;        // 0b11111111 - 每个光照通道8位 | Each light channel 8 bits
                 const SHIFT_LIGHT_R = 8u;       // 红色通道从第8位开始 | Red channel starts at bit 8
                 const SHIFT_LIGHT_G = 16u;      // 绿色通道从第16位开始 | Green channel starts at bit 16
                 const SHIFT_LIGHT_B = 24u;      // 蓝色通道从第24位开始 | Blue channel starts at bit 24

                 // 📦 解包后的体素结构 | Unpacked Voxel Structure
                 // 将32位整数解包成易于使用的结构 | Unpacks 32-bit integer into easy-to-use structure
                 struct UnpackedVoxel {
                     v_type: u32,        // 体素类型 | Voxel type
                     v_variant: u32,     // 颜色变体 | Color variant
                     is_updated: u32,    // 本帧是否已更新 | Whether updated this frame
                     light: vec3<f32>,   // RGB光照值 | RGB lighting value
                 };

                 // 🔓 解包函数：从32位整数提取体素信息 | Unpack function: extract voxel info from 32-bit integer
                 fn unpackVoxel(data: u32) -> UnpackedVoxel {
                     var result: UnpackedVoxel;
                     // 使用位操作提取每个字段 | Use bit operations to extract each field
                     result.v_type = (data >> SHIFT_TYPE) & MASK_TYPE;
                     result.v_variant = (data >> SHIFT_VARIANT) & MASK_VARIANT;
                     result.is_updated = (data >> SHIFT_UPDATED) & MASK_UPDATED;
                     // 提取RGB光照值并归一化到0-1范围 | Extract RGB lighting and normalize to 0-1 range
                     let r = f32((data >> SHIFT_LIGHT_R) & MASK_LIGHT);
                     let g = f32((data >> SHIFT_LIGHT_G) & MASK_LIGHT);
                     let b = f32((data >> SHIFT_LIGHT_B) & MASK_LIGHT);
                     result.light = vec3(r, g, b) / 255.0;
                     return result;
                 }

                 // 🔒 打包函数：将体素信息压缩到32位整数 | Pack function: compress voxel info into 32-bit integer
                 fn packVoxel(v_type: u32, v_variant: u32, is_updated: u32, light: vec3<f32>) -> u32 {
                     // 将光照值从0-1范围转换到0-255范围 | Convert lighting from 0-1 range to 0-255 range
                     let r = u32(clamp(light.r * 255.0, 0.0, 255.0));
                     let g = u32(clamp(light.g * 255.0, 0.0, 255.0));
                     let b = u32(clamp(light.b * 255.0, 0.0, 255.0));
                     // 使用位或操作将所有字段组合到一个整数中 | Use bit OR to combine all fields into one integer
                     return ((v_type & MASK_TYPE) << SHIFT_TYPE) |
                            ((v_variant & MASK_VARIANT) << SHIFT_VARIANT) |
                            ((is_updated & MASK_UPDATED) << SHIFT_UPDATED) |
                            ((r & MASK_LIGHT) << SHIFT_LIGHT_R) |
                            ((g & MASK_LIGHT) << SHIFT_LIGHT_G) |
                            ((b & MASK_LIGHT) << SHIFT_LIGHT_B);
                 }

                 // 快速提取函数：只获取类型和更新标志 | Fast extract functions: get only type and update flag
                 fn getVoxelType(data: u32) -> u32 { return (data >> SHIFT_TYPE) & MASK_TYPE; }
                 fn getVoxelIsUpdated(data: u32) -> u32 { return (data >> SHIFT_UPDATED) & MASK_UPDATED; }

                 // 📍 坐标转索引函数 | Coordinate to index functions
                 // 将3D坐标(x,y,z)转换为1D数组索引 | Convert 3D coordinates (x,y,z) to 1D array index
                 // 使用公式: index = x + y*WIDTH + z*WIDTH*HEIGHT | Formula: index = x + y*WIDTH + z*WIDTH*HEIGHT
                 fn pos_to_idx(pos: vec3<u32>) -> u32 {
                     // 检查坐标是否越界 | Check if coordinates are out of bounds
                     if (any(pos >= vec3(GRID_DIM))) { return 0xFFFFFFFFu; }  // 返回无效索引 | Return invalid index
                     return pos.x + pos.y * GRID_DIM + pos.z * GRID_DIM * GRID_DIM;
                 }
                 
                 // 带符号整数版本 | Signed integer version
                 fn pos_to_idx_i32(pos: vec3<i32>) -> u32 {
                     if (any(pos < vec3(0)) || any(pos >= vec3<i32>(i32(GRID_DIM)))) { return 0xFFFFFFFFu; }
                     return u32(pos.x + pos.y * i32(GRID_DIM) + pos.z * i32(GRID_DIM) * i32(GRID_DIM));
                 }
                 
                 // 🎲 3D哈希函数：将3D坐标转换为伪随机浮点数 | 3D hash function: convert 3D coordinates to pseudo-random float
                 // 用于生成随机变体和噪声 | Used to generate random variants and noise
                 fn hash3d_to_float(p: vec3<u32>) -> f32 {
                     var p_mut = p * vec3(374761393u, 668265263u, 104395301u);  // 大质数 | Large primes
                     p_mut = (p_mut ^ p_mut.yzx ^ p_mut.zxy) >> vec3(8u);
                     p_mut = p_mut * vec3(374761393u, 668265263u, 104395301u);
                     return f32(p_mut.x ^ p_mut.y ^ p_mut.z) / 4294967295.0;  // 归一化到0-1 | Normalize to 0-1
                 }
             `;

             const generationShaderCode = `
                 ${commonShaderCode}
                 struct GenerationUniforms { terrain_type: u32 };
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> gen_uniforms: GenerationUniforms;
                 fn noise(p: vec2<f32>) -> f32 { return sin(p.x*0.1) * cos(p.y*0.1); }
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                     let idx = pos_to_idx(global_id);
                     if (idx == 0xFFFFFFFFu) { return; }
                     var v_type = VOXEL_TYPE_AIR;
                     let variant = u32(hash3d_to_float(global_id) * 8.0);

                     if (gen_uniforms.terrain_type == 1u) {
                         let h = 32.0 + noise(vec2<f32>(global_id.xz)) * 10.0 + noise(vec2<f32>(global_id.xz) * 2.5) * 4.0;
                         if (f32(global_id.y) < h) {
                             v_type = select(VOXEL_TYPE_SAND, VOXEL_TYPE_STONE, f32(global_id.y) < h - 4.0);
                         }
                     } else {
                         if (global_id.y < 5u) {
                             v_type = VOXEL_TYPE_STONE;
                         } else if (global_id.y < 10u && global_id.x > 10u && global_id.x < GRID_DIM - 10u && global_id.z > 10u && global_id.z < GRID_DIM - 10u) {
                             v_type = VOXEL_TYPE_WATER;
                         }
                     }
                     atomicStore(&voxels[idx].data, packVoxel(v_type, variant, 0u, vec3(0.0)));
                 }
             `;

             const simulationShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;

                 fn attempt_move(current_idx: u32, target_idx: u32, current_data: u32) -> bool {
                     let target_initial_data = atomicLoad(&voxels[target_idx].data);
                     if (getVoxelType(target_initial_data) != VOXEL_TYPE_AIR || getVoxelIsUpdated(target_initial_data) == 1u) {
                         return false;
                     }
                     let data_to_write = current_data | (1u << SHIFT_UPDATED);
                     let ex = atomicCompareExchangeWeak(&voxels[target_idx].data, target_initial_data, data_to_write);
                     if (ex.exchanged) {
                         atomicStore(&voxels[current_idx].data, 0u);
                         return true;
                     }
                     return false;
                 }

                 fn attempt_swap(current_idx: u32, target_idx: u32, current_data: u32) -> bool {
                     let target_initial_data = atomicLoad(&voxels[target_idx].data);
                     if (getVoxelIsUpdated(target_initial_data) == 1u) { return false; }

                     let marked_current_data = current_data | (1u << SHIFT_UPDATED);
                     let marked_target_data = target_initial_data | (1u << SHIFT_UPDATED);

                     let ex = atomicCompareExchangeWeak(&voxels[target_idx].data, target_initial_data, marked_current_data);
                     if (ex.exchanged) {
                         let ex2 = atomicCompareExchangeWeak(&voxels[current_idx].data, current_data, marked_target_data);
                         if (!ex2.exchanged) {
                             atomicStore(&voxels[target_idx].data, target_initial_data);
                             return false;
                         }
                         return true;
                     }
                     return false;
                 }

                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                     let current_idx = pos_to_idx(global_id);
                     if (current_idx == 0xFFFFFFFFu) { return; }

                     let initial_data = atomicLoad(&voxels[current_idx].data);
                     let current_type = getVoxelType(initial_data);

                     if (getVoxelIsUpdated(initial_data) == 1u || current_type == VOXEL_TYPE_AIR || current_type == VOXEL_TYPE_STONE) {
                         return;
                     }

                     // Don't delete player voxel if it reaches bottom, but delete other loose voxels
                     if (global_id.y == 0u) {
                         if (current_type != VOXEL_TYPE_PLAYER) {
                             atomicStore(&voxels[current_idx].data, 0u);
                         }
                         return;
                     }

                     // PRIORITY 1: Direct Vertical Fall
                     let pos_below = global_id - vec3(0u, 1u, 0u);
                     let idx_below = pos_to_idx(pos_below);
                     if (idx_below != 0xFFFFFFFFu) {
                         let type_below = getVoxelType(atomicLoad(&voxels[idx_below].data));
                         if (type_below == VOXEL_TYPE_AIR) {
                             if (attempt_move(current_idx, idx_below, initial_data)) { return; }
                         } else if ((current_type == VOXEL_TYPE_SAND || current_type == VOXEL_TYPE_PLAYER) && type_below == VOXEL_TYPE_WATER) {
                             if (attempt_swap(current_idx, idx_below, initial_data)) { return; }
                         }
                     }

                     let time_varied_hash = (global_id.x * 19349663u) ^ (global_id.y * 668265263u) ^ (global_id.z * 374761393u) ^ tool_info.frame_num;

                     // PRIORITY 2: Diagonal Fall
                     if (global_id.y > 0u) {
                         if (current_type == VOXEL_TYPE_SAND || current_type == VOXEL_TYPE_PLAYER) {
                             let DIAGONAL_SLIDES_SAND = array<vec3<i32>, 8>(
                                 vec3(1,-1,0), vec3(-1,-1,0), vec3(0,-1,1), vec3(0,-1,-1),
                                 vec3(1,-1,1), vec3(-1,-1,1), vec3(1,-1,-1), vec3(-1,-1,-1)
                             );
                             let offset_diag_sand = time_varied_hash % 8u;
                             for(var i_ds = 0u; i_ds < 8u; i_ds = i_ds + 1u) {
                                 let check_pos = vec3<i32>(global_id) + DIAGONAL_SLIDES_SAND[(i_ds + offset_diag_sand) % 8u];
                                 let check_idx = pos_to_idx_i32(check_pos);
                                 if (check_idx != 0xFFFFFFFFu) {
                                     let type_diag = getVoxelType(atomicLoad(&voxels[check_idx].data));
                                     if (type_diag == VOXEL_TYPE_AIR) {
                                         if(attempt_move(current_idx, check_idx, initial_data)) { return; }
                                     } else if (type_diag == VOXEL_TYPE_WATER) { // Sand/Player swaps with water diagonally
                                         if(attempt_swap(current_idx, check_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         } else if (current_type == VOXEL_TYPE_WATER) {
                              let DIAGONAL_DIRS_WATER = array<vec3<i32>, 4>(vec3(-1,-1,0), vec3(1,-1,0), vec3(0,-1,-1), vec3(0,-1,1));
                              let offset_diag_water = time_varied_hash % 4u;
                              for(var i_dw = 0u; i_dw < 4u; i_dw = i_dw + 1u) {
                                 let check_pos = vec3<i32>(global_id) + DIAGONAL_DIRS_WATER[(i_dw + offset_diag_water) % 4u];
                                 let check_idx = pos_to_idx_i32(check_pos);
                                  if (check_idx != 0xFFFFFFFFu) {
                                     if (getVoxelType(atomicLoad(&voxels[check_idx].data)) == VOXEL_TYPE_AIR) { // Water only moves into air diagonally
                                        if(attempt_move(current_idx, check_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }

                     // PRIORITY 3: Tumbling (Sand and Water)
                     if (global_id.y > 0u) {
                         let HORIZONTAL_TUMBLE_DIRS = array<vec3<i32>,4>(vec3(1,0,0),vec3(-1,0,0),vec3(0,0,1),vec3(0,0,-1));
                         let offset_tumble = (time_varied_hash >> 3u) % 4u;
                         for(var i_t=0u; i_t<4u; i_t++){
                             let horizontal_dir = HORIZONTAL_TUMBLE_DIRS[(i_t + offset_tumble) % 4u];
                             let h_n_pos = vec3<i32>(global_id) + horizontal_dir;
                             let h_n_idx = pos_to_idx_i32(h_n_pos);

                             if(h_n_idx != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[h_n_idx].data)) == VOXEL_TYPE_AIR){
                                 let tumble_target_pos = h_n_pos - vec3(0,1,0);
                                 if(tumble_target_pos.y >= 0){
                                     let tumble_target_idx = pos_to_idx_i32(tumble_target_pos);
                                     if(tumble_target_idx != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[tumble_target_idx].data)) == VOXEL_TYPE_AIR){
                                        if(attempt_move(current_idx, tumble_target_idx, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }

                     // PRIORITY 4: Water Horizontal Spread (specific to water)
                     if (current_type == VOXEL_TYPE_WATER) {
                         let HORIZONTAL_SPREAD_DIRS_WATER = array<vec3<i32>, 4>(vec3(-1,0,0), vec3(1,0,0), vec3(0,0,-1), vec3(0,0,1));
                         let offset_h_water = (time_varied_hash >> 4u) % 4u;
                          for(var i_hw = 0u; i_hw < 4u; i_hw = i_hw + 1u) {
                             let dir = HORIZONTAL_SPREAD_DIRS_WATER[(i_hw + offset_h_water) % 4u];
                             let neighbor_idx_1 = pos_to_idx_i32(vec3<i32>(global_id) + dir);
                             if (neighbor_idx_1 != 0xFFFFFFFFu) {
                                 let neighbor_type_1 = getVoxelType(atomicLoad(&voxels[neighbor_idx_1].data));
                                 if (neighbor_type_1 == VOXEL_TYPE_AIR) {
                                     if (attempt_move(current_idx, neighbor_idx_1, initial_data)) { return; }
                                 } else if (neighbor_type_1 == VOXEL_TYPE_WATER) {
                                     let neighbor_idx_2 = pos_to_idx_i32(vec3<i32>(global_id) + dir * 2);
                                     if (neighbor_idx_2 != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[neighbor_idx_2].data)) == VOXEL_TYPE_AIR) {
                                          if (attempt_move(current_idx, neighbor_idx_2, initial_data)) { return; }
                                     }
                                 }
                             }
                         }
                     }
                 }
             `;

             const resetFlagsShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @compute @workgroup_size(8, 8, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx != 0xFFFFFFFFu) {
                         atomicAnd(&voxels[idx].data, ~((1u) << SHIFT_UPDATED));
                     }
                 }
             `;

             const lightingShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> scene: SceneUniforms;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx == 0xFFFFFFFFu) { return; }

                     let current_packed = unpackVoxel(atomicLoad(&voxels[idx].data));
                     if (current_packed.v_type == VOXEL_TYPE_STONE || current_packed.v_type == VOXEL_TYPE_AIR) {
                         let packed_no_light = packVoxel(current_packed.v_type, current_packed.v_variant, 0u, vec3(0.0));
                         atomicStore(&voxels[idx].data, packed_no_light);
                         return;
                     }

                     var final_light_color = vec3(0.0);
                     let voxel_pos = vec3<f32>(id) + 0.5;
                     for (var i = 0u; i < scene.light_count; i = i + 1u) {
                         let light = scene.lights[i];
                         let dist_sq = dot(voxel_pos - light.pos, voxel_pos - light.pos);
                         let radius_sq = light.radius * light.radius;
                         if (dist_sq < radius_sq) {
                             let falloff = pow(1.0 - (dist_sq / radius_sq), 2.0);
                             final_light_color += light.color * falloff * light.intensity;
                         }
                     }
                     atomicStore(&voxels[idx].data, packVoxel(current_packed.v_type, current_packed.v_variant, 0u, final_light_color));
                 }
             `;

             const paintShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;
                 @group(0) @binding(2) var<storage, read> targeting: TargetingOutput;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) global_id_in_brush: vec3<u32>) {
                     if(tool_info.is_painting == 0u || targeting.hit == 0u) { return; }
                     let brush_radius_f = tool_info.brush_size;
                     let brush_center_world_f = targeting.aim_pos.xyz;
                     let local_pos_in_brush = vec3<f32>(global_id_in_brush) - vec3(brush_radius_f) + 0.5;
                     if (length(local_pos_in_brush) > brush_radius_f) { return; }
                     let p_world_u = vec3<u32>(floor(brush_center_world_f + local_pos_in_brush));
                     let idx = pos_to_idx(p_world_u);
                     if (idx != 0xFFFFFFFFu) {
                         if (tool_info.tool_type == TOOL_TYPE_DESTROY) {
                             atomicStore(&voxels[idx].data, 0u);
                         } else {
                             if (getVoxelType(atomicLoad(&voxels[idx].data)) == VOXEL_TYPE_AIR) {
                                 var new_voxel_type: u32;
                                 if (tool_info.tool_type == TOOL_TYPE_SAND) { new_voxel_type = VOXEL_TYPE_SAND; }
                                 else if (tool_info.tool_type == TOOL_TYPE_WATER) { new_voxel_type = VOXEL_TYPE_WATER; }
                                 else { new_voxel_type = VOXEL_TYPE_STONE; }
                                 let variant = u32(hash3d_to_float(p_world_u) * 8.0);
                                 atomicStore(&voxels[idx].data, packVoxel(new_voxel_type, variant, 1u, vec3(0.0)));
                             }
                         }
                     }
                 }
             `;

             const clearLooseVoxelsShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @compute @workgroup_size(4, 4, 4)
                 fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                     let idx = pos_to_idx(id);
                     if (idx != 0xFFFFFFFFu) {
                         let v_type = getVoxelType(atomicLoad(&voxels[idx].data));
                         if(v_type == VOXEL_TYPE_SAND || v_type == VOXEL_TYPE_WATER){
                             atomicStore(&voxels[idx].data, 0u);
                         }
                     }
                 }
             `;

            const findPlayerShaderCode = `
                ${commonShaderCode}
                @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                @group(0) @binding(1) var<storage, read_write> player_pos_output: array<atomic<u32>, 4>; // xyz position + found flag
                
                @compute @workgroup_size(4, 4, 4)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let idx = pos_to_idx(id);
                    if (idx != 0xFFFFFFFFu) {
                        let v_type = getVoxelType(atomicLoad(&voxels[idx].data));
                        if (v_type == VOXEL_TYPE_PLAYER) {
                            // Found the player voxel, write its position atomically
                            // Only first thread to find player will write (race is acceptable)
                            atomicStore(&player_pos_output[0], id.x);
                            atomicStore(&player_pos_output[1], id.y);
                            atomicStore(&player_pos_output[2], id.z);
                            atomicStore(&player_pos_output[3], 1u);
                        }
                    }
                }
            `;

            const managePlayerShaderCode = `
                ${commonShaderCode}
                @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;
                @group(0) @binding(2) var<storage, read_write> player_pos_output: array<atomic<u32>, 4>;
                
                @compute @workgroup_size(1, 1, 1)
                fn main() {
                    // Get desired camera position from uniforms
                    let camera_pos = tool_info.camera_position;
                    let target_pos = vec3<u32>(
                        clamp(u32(floor(camera_pos.x)), 0u, GRID_DIM - 1u),
                        clamp(u32(floor(camera_pos.y)), 0u, GRID_DIM - 1u),
                        clamp(u32(floor(camera_pos.z)), 0u, GRID_DIM - 1u)
                    );
                    
                    // Check if player voxel already exists at last known position
                    let last_found = atomicLoad(&player_pos_output[3]);
                    if (last_found == 1u) {
                        let last_pos = vec3<u32>(
                            atomicLoad(&player_pos_output[0]),
                            atomicLoad(&player_pos_output[1]),
                            atomicLoad(&player_pos_output[2])
                        );
                        let last_idx = pos_to_idx(last_pos);
                        if (last_idx != 0xFFFFFFFFu) {
                            let voxel_data = atomicLoad(&voxels[last_idx].data);
                            if (getVoxelType(voxel_data) == VOXEL_TYPE_PLAYER) {
                                // Player voxel still exists and is falling with physics
                                // Just clear found flag for next frame's search
                                atomicStore(&player_pos_output[3], 0u);
                                return;
                            }
                        }
                    }
                    
                    // Player voxel doesn't exist (fell off or was destroyed), create new one at camera position
                    let target_idx = pos_to_idx(target_pos);
                    if (target_idx != 0xFFFFFFFFu) {
                        // Always try to place player voxel, even if occupied (will replace)
                        // This ensures player is always visible near camera
                        atomicStore(&voxels[target_idx].data, packVoxel(VOXEL_TYPE_PLAYER, 0u, 0u, vec3(0.0)));
                        
                        // Update player position output with found flag cleared for next search
                        atomicStore(&player_pos_output[0], target_pos.x);
                        atomicStore(&player_pos_output[1], target_pos.y);
                        atomicStore(&player_pos_output[2], target_pos.z);
                        atomicStore(&player_pos_output[3], 0u);
                    }
                }
            `;

             const targetingShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> tool_info: ComputePassUniforms;
                 @group(0) @binding(2) var<storage, read_write> output: TargetingOutput;
                 fn intersect_aabb(ro: vec3<f32>, rd: vec3<f32>, min_b: vec3<f32>, max_b: vec3<f32>) -> vec2<f32> {
                     let inv_rd = 1.0 / rd; let t1 = (min_b - ro) * inv_rd; let t2 = (max_b - ro) * inv_rd;
                     let t_min = max(max(min(t1.x, t2.x), min(t1.y, t2.y)), min(t1.z, t2.z));
                     let t_max = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
                     return vec2(t_min, t_max);
                 }
                 @compute @workgroup_size(1, 1, 1)
                 fn main() {
                     output.hit = 0u;
                     var ray_origin = tool_info.camera_position;
                     let cam_fwd = normalize(tool_info.camera_target_pos - ray_origin);
                     let aspect_ratio = tool_info.canvas_dims.x / tool_info.canvas_dims.y;
                     let ray_dir = normalize(tool_info.camera_right * ((tool_info.mouse_pos.x/tool_info.canvas_dims.x)-0.5)*2.0*aspect_ratio + tool_info.camera_up * ((tool_info.mouse_pos.y/tool_info.canvas_dims.y)-0.5)*-2.0 + cam_fwd*tool_info.camera_zoom);
                     let t_bounds = intersect_aabb(ray_origin, ray_dir, vec3(0.0), vec3(f32(GRID_DIM)));

                     if (t_bounds.x >= t_bounds.y || t_bounds.y < 0.0 ) { return; }

                     var dda_pos = ray_origin + ray_dir * (max(0.0, t_bounds.x) - 0.001);
                     var map_pos = vec3<i32>(floor(dda_pos));
                     let step = vec3<i32>(sign(ray_dir));
                     let delta = abs(1.0 / (ray_dir + 1e-6));
                     var side = (sign(ray_dir) * (vec3<f32>(map_pos) - dda_pos) + (sign(ray_dir) * 0.5 + 0.5)) * delta;
                     var last_map_pos = map_pos;

                     for (var i = 0u; i < tool_info.max_ray_steps_compute; i = i + 1u) {
                         last_map_pos = map_pos;
                         if (side.x < side.y && side.x < side.z) { side.x += delta.x; map_pos.x += step.x; }
                         else if (side.y < side.z) { side.y += delta.y; map_pos.y += step.y; }
                         else { side.z += delta.z; map_pos.z += step.z; }

                         let idx = pos_to_idx(vec3<u32>(map_pos));
                         if (idx != 0xFFFFFFFFu && getVoxelType(atomicLoad(&voxels[idx].data)) != VOXEL_TYPE_AIR) {
                             var hit_pos_f = select(vec3<f32>(last_map_pos), vec3<f32>(map_pos), tool_info.tool_type == TOOL_TYPE_DESTROY);
                             output.aim_pos = vec4(hit_pos_f + 0.5, 0.0);
                             output.hit = 1u;
                             return;
                         }
                         if (any(map_pos < vec3<i32>(0)) || any(map_pos >= vec3<i32>(i32(GRID_DIM)))) { break; }
                     }

                     let dist_to_bbox_hit: f32 = select(max(0.0, t_bounds.x), t_bounds.y, tool_info.target_far_face_on_air_hit == 1u);
                     let hit_pos_on_bbox = ray_origin + ray_dir * dist_to_bbox_hit;
                     let target_point_for_placement: vec3<f32> = select(hit_pos_on_bbox + ray_dir * 0.501, hit_pos_on_bbox - ray_dir * 0.501, tool_info.target_far_face_on_air_hit == 1u);
                     output.aim_pos = vec4(clamp(target_point_for_placement, vec3(0.0), vec3(f32(GRID_DIM) - 1.0)), 0.0);
                     output.hit = 1u;
                 }
             `;

             const renderShaderCode = `
                 ${commonShaderCode}
                 @group(0) @binding(0) var<storage, read_write> voxels: array<VoxelData>;
                 @group(0) @binding(1) var<uniform> scene: RenderPassUniforms;
                 @group(0) @binding(2) var<uniform> tool_info: ComputePassUniforms;
                 @group(0) @binding(3) var<storage, read> targeting: TargetingOutput;

                 fn getColorFromVoxel(voxel: UnpackedVoxel, is_water: bool) -> vec3<f32> {
                     let variant_f = f32(voxel.v_variant) / 7.0;
                     if (voxel.v_type == VOXEL_TYPE_STONE) {
                         return vec3(0.45) + (variant_f - 0.5) * 0.15;
                     }
                     if (voxel.v_type == VOXEL_TYPE_SAND) {
                         return vec3(0.8, 0.7, 0.4) + (variant_f - 0.5) * 0.1;
                     }
                     if (voxel.v_type == VOXEL_TYPE_PLAYER) {
                         return vec3(0.2, 0.8, 0.2); // Bright green for player visibility
                     }
                     if (is_water) {
                         return vec3(0.15, 0.45, 0.85); // Flat base color for water, variant removed
                     }
                     // This should not be reached for water if logic is correct, but acts as a fallback.
                     return vec3(0.15, 0.45, 0.85) + (variant_f - 0.5) * vec3(0.05, 0.05, 0.1);
                 }

                 fn intersect_aabb(ro: vec3<f32>, rd: vec3<f32>, min_b: vec3<f32>, max_b: vec3<f32>) -> vec2<f32> {
                     let t1=(min_b-ro)/rd; let t2=(max_b-ro)/rd;
                     return vec2(max(max(min(t1.x,t2.x),min(t1.y,t2.y)),min(t1.z,t2.z)),min(min(max(t1.x,t2.x),max(t1.y,t2.y)),max(t1.z,t2.z)));
                 }
                 fn intersect_sphere(ro: vec3<f32>, rd: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {
                     let oc = ro - c; let b = dot(oc, rd); let h = b*b - dot(oc, oc) + r*r;
                     if (h < 0.0) { return -1.0; } else { return -b - sqrt(h); }
                 }
                 
                 // Hash function for procedural noise
                 fn hash13(p3: vec3<f32>) -> f32 {
                     var p = fract(p3 * 0.1031);
                     p += dot(p, p.zyx + 31.32);
                     return fract((p.x + p.y) * p.z);
                 }
                 
                 // 3D value noise for cloud generation
                 fn noise3d(p: vec3<f32>) -> f32 {
                     let i = floor(p);
                     let f = fract(p);
                     let u = f * f * (3.0 - 2.0 * f);
                     
                     return mix(
                         mix(
                             mix(hash13(i + vec3(0.0, 0.0, 0.0)), hash13(i + vec3(1.0, 0.0, 0.0)), u.x),
                             mix(hash13(i + vec3(0.0, 1.0, 0.0)), hash13(i + vec3(1.0, 1.0, 0.0)), u.x),
                             u.y
                         ),
                         mix(
                             mix(hash13(i + vec3(0.0, 0.0, 1.0)), hash13(i + vec3(1.0, 0.0, 1.0)), u.x),
                             mix(hash13(i + vec3(0.0, 1.0, 1.0)), hash13(i + vec3(1.0, 1.0, 1.0)), u.x),
                             u.y
                         ),
                         u.z
                     );
                 }
                 
                 // Fractal Brownian Motion for clouds
                 fn fbm(p: vec3<f32>) -> f32 {
                     var value = 0.0;
                     var amplitude = 0.5;
                     var frequency = 1.0;
                     var p_var = p;
                     
                     for (var i = 0; i < 4; i = i + 1) {
                         value += amplitude * noise3d(p_var * frequency);
                         frequency *= 2.0;
                         amplitude *= 0.5;
                     }
                     
                     return value;
                 }
                 
                 // Enhanced sky rendering with sun and clouds
                 fn compute_sky_color(ray_dir: vec3<f32>, sun_dir: vec3<f32>, time: f32) -> vec3<f32> {
                     // Atmospheric gradient - horizon to zenith
                     let y_factor = max(ray_dir.y, 0.0);
                     let horizon_color = vec3(0.6, 0.75, 0.9);  // Light blue at horizon
                     let zenith_color = vec3(0.2, 0.4, 0.8);     // Deeper blue at zenith
                     var sky_color = mix(horizon_color, zenith_color, pow(y_factor, 0.6));
                     
                     // Add sunset/sunrise gradient near horizon
                     let sunset_factor = pow(1.0 - y_factor, 3.0) * max(sun_dir.y + 0.2, 0.0);
                     let sunset_color = vec3(1.0, 0.6, 0.3);
                     sky_color = mix(sky_color, sunset_color, sunset_factor * 0.4);
                     
                     // Sun disk
                     let sun_dot = dot(ray_dir, normalize(sun_dir));
                     let sun_intensity = pow(max(sun_dot, 0.0), 128.0);
                     let sun_glow = pow(max(sun_dot, 0.0), 8.0) * 0.15;
                     let sun_corona = pow(max(sun_dot, 0.0), 2.0) * 0.05;
                     sky_color += vec3(1.0, 0.95, 0.8) * (sun_intensity + sun_glow + sun_corona);
                     
                     // Procedural clouds (only in upper hemisphere for performance)
                     if (ray_dir.y > 0.05) {
                         // Map ray direction to cloud texture coordinates
                         let cloud_scale = 0.8;
                         let cloud_pos = vec3(ray_dir.x / (ray_dir.y + 0.1), time * 0.02, ray_dir.z / (ray_dir.y + 0.1)) * cloud_scale;
                         
                         // Generate cloud density with multiple octaves
                         var cloud_density = fbm(cloud_pos);
                         
                         // Add second layer of smaller clouds
                         let cloud_detail = noise3d(cloud_pos * 3.0 + vec3(time * 0.05, 0.0, 0.0)) * 0.3;
                         cloud_density = cloud_density * 0.7 + cloud_detail;
                         
                         // Sharpen clouds (make them more defined)
                         cloud_density = smoothstep(0.4, 0.7, cloud_density);
                         
                         // Cloud color influenced by sun
                         let cloud_sun_dot = dot(normalize(vec3(ray_dir.x, 0.0, ray_dir.z)), normalize(vec3(sun_dir.x, 0.0, sun_dir.z)));
                         let cloud_lighting = 0.7 + 0.3 * max(cloud_sun_dot, 0.0);
                         
                         let cloud_color = vec3(0.9, 0.92, 0.95) * cloud_lighting;
                         
                         // Fade clouds based on view angle (less visible when looking straight up or down)
                         let cloud_fade = smoothstep(0.05, 0.3, ray_dir.y) * (1.0 - smoothstep(0.7, 0.95, ray_dir.y));
                         cloud_density *= cloud_fade;
                         
                         // Blend clouds with sky
                         sky_color = mix(sky_color, cloud_color, cloud_density * 0.8);
                     }
                     
                     return sky_color;
                 }
                 @vertex fn vs_main(@builtin(vertex_index) vi: u32) -> @builtin(position) vec4<f32> {
                     return vec4(vec2(f32(vi/2u)*4.0-1.0, f32(vi%2u)*4.0-1.0), 0.0, 1.0);
                 }
                 @fragment fn fs_main(@builtin(position) fc: vec4<f32>) -> @location(0) vec4<f32> {
                     let cam_fwd = normalize(scene.camera_target_pos - scene.camera_position);
                     let aspect = scene.canvas_actual_dims.x / scene.canvas_actual_dims.y;
                     let ray_dir = normalize(scene.camera_right*((fc.x/scene.canvas_actual_dims.x)-0.5)*2.0*aspect + scene.camera_up*((fc.y/scene.canvas_actual_dims.y)-0.5)*-2.0 + cam_fwd*scene.camera_zoom);
                     let t_bounds = intersect_aabb(scene.camera_position, ray_dir, vec3(0.0), vec3(f32(GRID_DIM)));

                     var sky_color = compute_sky_color(ray_dir, scene.sun_direction, f32(tool_info.frame_num));
                     var final_color = vec4(sky_color, 1.0);

                     var dda_hit_this_ray = false;
                     var dda_hit_map_pos = vec3<i32>(0);

                     if (t_bounds.x < t_bounds.y && t_bounds.y > 0.0) {
                         var dda_pos = scene.camera_position + ray_dir * (max(0.0, t_bounds.x) - 0.001);
                         var map_pos = vec3<i32>(floor(dda_pos));
                         let step = vec3<i32>(sign(ray_dir));
                         let delta = abs(1.0 / (ray_dir + 1e-6));
                         var side = (sign(ray_dir) * (vec3<f32>(map_pos) - dda_pos) + (sign(ray_dir) * 0.5 + 0.5)) * delta;

                         for (var i = 0u; i < scene.max_ray_steps; i = i + 1u) {
                             var normal: vec3<f32>;
                             if (side.x < side.y && side.x < side.z) { side.x+=delta.x; map_pos.x+=step.x; normal=vec3(-f32(step.x),0,0); }
                             else if (side.y < side.z) { side.y+=delta.y; map_pos.y+=step.y; normal=vec3(0,-f32(step.y),0); }
                             else { side.z+=delta.z; map_pos.z+=step.z; normal=vec3(0,0,-f32(step.z)); }

                             let idx = pos_to_idx(vec3<u32>(map_pos));
                             if (idx != 0xFFFFFFFFu) {
                                 let voxel = unpackVoxel(atomicLoad(&voxels[idx].data));
                                 if (voxel.v_type != VOXEL_TYPE_AIR) {
                                     var base_color = getColorFromVoxel(voxel, voxel.v_type == VOXEL_TYPE_WATER);

                                     let sun_diffuse = max(dot(normal, normalize(scene.sun_direction)), 0.0) * 0.5 + 0.5;
                                     var y_bright: f32;

                                     if (voxel.v_type == VOXEL_TYPE_WATER) {
                                         // Surface shimmer
                                         let time_factor_surface = f32(tool_info.frame_num) * 0.05;
                                         let spatial_factor_surface = f32(map_pos.x) * 0.3 + f32(map_pos.z) * 0.3;
                                         let surface_shimmer_val = (sin(spatial_factor_surface + time_factor_surface) + cos(spatial_factor_surface * 0.7)) * 0.025 + 0.01;
                                         base_color += vec3(surface_shimmer_val * 0.5, surface_shimmer_val * 0.7, surface_shimmer_val);

                                         // Per-voxel internal body oscillation
                                         let internal_time = f32(tool_info.frame_num) * 0.11 + f32(map_pos.y) * 0.07;
                                         let p_hash_x = sin(f32(map_pos.x) * 0.61 + internal_time + f32(map_pos.z) * 0.23);
                                         let p_hash_y = cos(f32(map_pos.y) * 0.73 - internal_time * 0.71 + f32(map_pos.x) * 0.19);
                                         let p_hash_z = sin(f32(map_pos.z) * 0.57 + internal_time * 1.13 + f32(map_pos.y) * 0.29);
                                         let internal_oscillation = (p_hash_x * p_hash_y * p_hash_z) * 0.045;
                                         base_color += vec3(internal_oscillation * 0.3, internal_oscillation * 0.4, internal_oscillation * 0.7);

                                         // Enhanced Y-brightness for water
                                         let normalized_y = f32(map_pos.y) / f32(GRID_DIM - 1u);
                                         y_bright = pow(normalized_y, 2.5) * 2.8 + 0.2; // Darker bottom, much brighter top (target ~0.2 to 3.0 range)
                                     } else {
                                         // Original y_bright for other materials
                                         y_bright = pow(f32(map_pos.y) / f32(GRID_DIM), 0.75) * 1.25 + 0.25;
                                     }

                                     var lit_color = base_color * sun_diffuse * y_bright + voxel.light;
                                     // No general water multiplier here anymore, y_bright handles it.

                                     final_color = vec4(clamp(lit_color, vec3(0.0), vec3(1.0)), 1.0);
                                     dda_hit_this_ray = true;
                                     dda_hit_map_pos = map_pos;
                                     break;
                                 }
                             }
                         }
                     }

                     if (dda_hit_this_ray && tool_info.preview_active == 1u && targeting.hit == 1u) {
                         let hit_center = vec3<f32>(dda_hit_map_pos) + 0.5;
                         let dist_to_brush = length(hit_center - targeting.aim_pos.xyz);
                         if (dist_to_brush <= tool_info.brush_size) {
                            var tool_color_indicator = vec3(0.0);
                            if (tool_info.tool_type == TOOL_TYPE_DESTROY) { tool_color_indicator = vec3(1.0, 0.2, 0.2); }
                            else if (tool_info.tool_type == TOOL_TYPE_WATER) { tool_color_indicator = vec3(0.3, 0.6, 1.0); }
                            else if (tool_info.tool_type == TOOL_TYPE_SAND) { tool_color_indicator = vec3(0.95, 0.85, 0.3); }
                            else { tool_color_indicator = vec3(0.6, 0.7, 1.0); }
                            let falloff = pow(1.0 - clamp(dist_to_brush/tool_info.brush_size, 0.0, 1.0), 1.5);
                            final_color = vec4<f32>(mix(final_color.rgb, tool_color_indicator, falloff * 0.6), final_color.a);
                         }
                     }

                     if (tool_info.preview_active == 1u && targeting.hit == 1u) {
                         let t_sphere = intersect_sphere(scene.camera_position, ray_dir, targeting.aim_pos.xyz, tool_info.brush_size);
                         if (t_sphere > 0.0) {
                             let hit_pos_on_sphere = scene.camera_position + ray_dir * t_sphere;
                             let sphere_normal = normalize(hit_pos_on_sphere - targeting.aim_pos.xyz);
                             let fresnel = pow(1.0 - abs(dot(sphere_normal, -ray_dir)), 4.0);
                             var sphere_base_tint = vec3(0.0);
                             if(tool_info.tool_type == TOOL_TYPE_DESTROY) { sphere_base_tint=vec3(1.0,0.2,0.2); }
                             else if (tool_info.tool_type == TOOL_TYPE_WATER) { sphere_base_tint=vec3(0.3, 0.6, 1.0); }
                             else if (tool_info.tool_type == TOOL_TYPE_SAND) { sphere_base_tint=vec3(0.95, 0.85, 0.3); }
                             else { sphere_base_tint=vec3(0.6, 0.7, 1.0); }
                             let sphere_blend_alpha = clamp(0.35 + fresnel * 0.6, 0.1, 0.9);
                             final_color = vec4<f32>(mix(final_color.rgb, sphere_base_tint, sphere_blend_alpha), final_color.a);
                         }
                     }
                     return final_color;
                 }
             `;

             // ==================================================
             // 📦 GPU缓冲区创建 | GPU Buffer Creation
             // ==================================================
             // 缓冲区(Buffer)是GPU内存中的数据块 | Buffers are data blocks in GPU memory
             // 它们用于在CPU和GPU之间传递数据 | They're used to pass data between CPU and GPU
             
             // 📏 计算体素缓冲区大小 | Calculate voxel buffer size
             // 每个体素4字节(32位) | Each voxel is 4 bytes (32 bits)
             const VOXEL_BUFFER_SIZE = NUM_VOXELS * 4;
             
             // 🧱 体素缓冲区：存储所有体素数据 | Voxel buffer: stores all voxel data
             // 用途: STORAGE(计算着色器读写) | COPY_SRC/DST(可以复制)
             // Usage: STORAGE (compute shader read/write) | COPY_SRC/DST (can be copied)
             const voxelBuffer = device.createBuffer({ 
                 size: VOXEL_BUFFER_SIZE,  // 缓冲区大小(字节) | Buffer size in bytes
                 usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST 
             });
             
             // 🌍 世界生成参数缓冲区 | World generation parameters buffer
             // 只存储一个u32值：地形类型 | Stores only one u32 value: terrain type
             const generationUniformsBuffer = device.createBuffer({ 
                 size: 4,  // 4字节 = 1个u32 | 4 bytes = 1 u32
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // 📷 渲染通道统一缓冲区 | Render pass uniform buffer
             // 存储相机位置、方向、太阳方向等渲染参数 | Stores camera position, direction, sun direction, etc.
             const renderPassUniformsBuffer = device.createBuffer({ 
                 size: 104,  // 26个float(每个4字节) = 104字节 | 26 floats (4 bytes each) = 104 bytes
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // 🖥️ 计算通道统一缓冲区 | Compute pass uniform buffer
             // 存储物理模拟和工具交互所需的参数 | Stores parameters for physics simulation and tool interaction
             const computePassUniformsBuffer = device.createBuffer({ 
                 size: 144,  // 36个float/uint = 144字节 | 36 floats/uints = 144 bytes
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });
             
             // 🎯 目标输出缓冲区 | Targeting output buffer
             // 存储光线追踪找到的目标位置 | Stores target position found by ray tracing
             const targetingOutputBuffer = device.createBuffer({ 
                 size: 32,  // vec4<f32> + u32 + 填充 | vec4<f32> + u32 + padding
                 usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC 
             });
             
             // 🧍 玩家位置输出缓冲区 | Player position output buffer
             // 存储GPU找到的玩家体素位置 | Stores player voxel position found by GPU
             const playerPosBuffer = device.createBuffer({
                 size: 16,  // vec4<u32> = 16 bytes (x, y, z, found_flag)
                 usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
             });
             
             // 玩家位置读取缓冲区 | Player position readback buffer  
             // 用于从GPU读回玩家位置到CPU | Used to read back player position from GPU to CPU
             const playerPosReadBuffer = device.createBuffer({
                 size: 16,
                 usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
             });
             
             // Flag to track if a map operation is pending on playerPosReadBuffer
             // 标志位：追踪玩家位置缓冲区是否有待处理的映射操作
             let playerPosMapPending = false;
             
             // 💡 光源统一缓冲区 | Lights uniform buffer
             // 存储所有动态点光源的数据 | Stores data for all dynamic point lights
             const lightsUniformBuffer = device.createBuffer({ 
                 size: 32 * NUM_LIGHTS + 16,  // 每个光源32字节 + 16字节元数据 | 32 bytes per light + 16 bytes metadata
                 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
             });

             // ==================================================
             // 🔧 GPU管线创建 | GPU Pipeline Creation
             // ==================================================
             // 管线(Pipeline)定义了GPU如何处理数据 | Pipelines define how GPU processes data
             // 每个管线包含着色器代码和配置 | Each pipeline contains shader code and configuration
             
             // 🌍 世界生成管线 | World generation pipeline
             // 用途: 初始化体素网格，生成地形或平坦世界 | Purpose: Initialize voxel grid, generate terrain or flat world
             const generationPipeline = device.createComputePipeline({ 
                 layout: 'auto',  // 自动推断布局 | Auto-infer layout
                 compute: { 
                     module: device.createShaderModule({ code: generationShaderCode }),  // 编译着色器代码 | Compile shader code
                     entryPoint: 'main'  // 入口函数名 | Entry function name
                 }
             });
             
             // ⚡ 物理模拟管线 | Physics simulation pipeline
             // 用途: 模拟沙子下落、水流动等物理效果 | Purpose: Simulate sand falling, water flowing, etc.
             const simulationPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: simulationShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 🔄 重置标志管线 | Reset flags pipeline
             // 用途: 清除每帧的"已更新"标志，准备下一帧物理模拟 | Purpose: Clear "updated" flags each frame for next physics step
             const resetFlagsPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: resetFlagsShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 💡 光照计算管线 | Lighting calculation pipeline
             // 用途: 计算动态点光源对体素的照明 | Purpose: Calculate dynamic point light illumination on voxels
             const lightingPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: lightingShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 🖌️ 绘制工具管线 | Paint tool pipeline
             // 用途: 应用用户的绘制操作(添加/删除体素) | Purpose: Apply user's painting operations (add/remove voxels)
             const paintPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: paintShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 🧹 清除松散体素管线 | Clear loose voxels pipeline
             // 用途: 移除所有沙子和水，只保留石头 | Purpose: Remove all sand and water, keep only stone
             const clearLooseVoxelsPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: clearLooseVoxelsShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 🎯 目标定位管线 | Targeting pipeline
             // 用途: GPU光线追踪找到鼠标指向的3D位置 | Purpose: GPU ray tracing to find 3D position under mouse cursor
             const targetingPipeline = device.createComputePipeline({ 
                 layout: 'auto', 
                 compute: { 
                     module: device.createShaderModule({ code: targetingShaderCode }), 
                     entryPoint: 'main' 
                 }
             });
             
             // 🔍 寻找玩家管线 | Find player pipeline
             // 用途: GPU扫描找到玩家体素位置 | Purpose: GPU scan to find player voxel position
             const findPlayerPipeline = device.createComputePipeline({
                 layout: 'auto',
                 compute: {
                     module: device.createShaderModule({ code: findPlayerShaderCode }),
                     entryPoint: 'main'
                 }
             });
             
             // 🧍 管理玩家管线 | Manage player pipeline
             // 用途: 创建/维护玩家体素 | Purpose: Create/maintain player voxel
             const managePlayerPipeline = device.createComputePipeline({
                 layout: 'auto',
                 compute: {
                     module: device.createShaderModule({ code: managePlayerShaderCode }),
                     entryPoint: 'main'
                 }
             });
             
             // 🎨 渲染管线 | Render pipeline
             // 用途: 将3D体素世界渲染到2D屏幕 | Purpose: Render 3D voxel world to 2D screen
             // 这是唯一的渲染管线，其他都是计算管线 | This is the only render pipeline, others are compute pipelines
             let renderPipeline = device.createRenderPipeline({
                 layout: 'auto',
                 vertex: { 
                     module: device.createShaderModule({ code: renderShaderCode }), 
                     entryPoint: 'vs_main'  // 顶点着色器入口 | Vertex shader entry
                 },
                 fragment: { 
                     module: device.createShaderModule({ code: renderShaderCode }), 
                     entryPoint: 'fs_main',  // 片段着色器入口 | Fragment shader entry
                     targets: [{ 
                         format: presentationFormat,  // 输出格式 | Output format
                         // 混合模式: 支持透明度 | Blend mode: supports transparency
                         blend: {
                             color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                             alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                         }
                      }] 
                 },
                 primitive: { topology: 'triangle-list' },  // 绘制三角形 | Draw triangles
             });

             // ==================================================
             // 🔗 绑定组创建 | Bind Group Creation
             // ==================================================
             // 绑定组(Bind Group)将缓冲区绑定到着色器 | Bind groups connect buffers to shaders
             // 每个管线需要知道从哪里读取数据，绑定组提供这个映射 | Each pipeline needs to know where to read data, bind groups provide this mapping
             
             // 🌍 世界生成绑定组 | World generation bind group
             // 绑定: 体素缓冲区(读写) + 生成参数(只读) | Binds: voxel buffer (read/write) + generation params (read-only)
             const generationBindGroup = device.createBindGroup({ 
                 layout: generationPipeline.getBindGroupLayout(0),  // 从管线获取布局 | Get layout from pipeline
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } },           // @binding(0): 体素数据 | voxel data
                     { binding: 1, resource: { buffer: generationUniformsBuffer } } // @binding(1): 生成参数 | generation params
                 ]
             });
             
             // ⚡ 物理模拟绑定组 | Physics simulation bind group
             // 绑定: 体素缓冲区(读写) + 计算参数(只读) | Binds: voxel buffer (read/write) + compute params (read-only)
             const simulationBindGroup = device.createBindGroup({ 
                 layout: simulationPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }
                 ]
             });
             
             // 🔄 重置标志绑定组 | Reset flags bind group
             // 只需要体素缓冲区 | Only needs voxel buffer
             const resetFlagsBindGroup = device.createBindGroup({ 
                 layout: resetFlagsPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }
                 ]
             });
             
             // 💡 光照计算绑定组 | Lighting calculation bind group
             // 绑定: 体素缓冲区(读写) + 光源数据(只读) | Binds: voxel buffer (read/write) + light data (read-only)
             const lightBindGroup = device.createBindGroup({ 
                 layout: lightingPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: lightsUniformBuffer } }
                 ]
             });
             
             // 🖌️ 绘制工具绑定组 | Paint tool bind group
             // 绑定: 体素缓冲区(读写) + 工具参数(只读) + 目标位置(只读) | Binds: voxel buffer + tool params + target position
             const paintBindGroup = device.createBindGroup({ 
                 layout: paintPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: targetingOutputBuffer } }
                 ]
             });
             
             // 🧹 清除松散体素绑定组 | Clear loose voxels bind group
             const clearLooseBindGroup = device.createBindGroup({ 
                 layout: clearLooseVoxelsPipeline.getBindGroupLayout(0), 
                 entries: [
                     { binding: 0, resource: { buffer: voxelBuffer } }
                 ]
             });
             
             // 🎯 目标定位绑定组 | Targeting bind group
             // 绑定: 体素缓冲区(只读) + 计算参数(只读) + 输出缓冲区(写入) | Binds: voxel buffer + compute params + output buffer
             const targetingBindGroup = device.createBindGroup({ 
                 layout: targetingPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: targetingOutputBuffer } }
                 ]
             });
             
             // 🔍 寻找玩家绑定组 | Find player bind group
             // 绑定: 体素缓冲区(只读) + 玩家位置输出(写入) | Binds: voxel buffer + player position output
             const findPlayerBindGroup = device.createBindGroup({
                 layout: findPlayerPipeline.getBindGroupLayout(0),
                 entries: [
                     { binding: 0, resource: { buffer: voxelBuffer } },
                     { binding: 1, resource: { buffer: playerPosBuffer } }
                 ]
             });
             
             // 🧍 管理玩家绑定组 | Manage player bind group
             // 绑定: 体素缓冲区(读写) + 计算参数(只读) + 玩家位置输出(读写) | Binds: voxel buffer + compute params + player position
             const managePlayerBindGroup = device.createBindGroup({
                 layout: managePlayerPipeline.getBindGroupLayout(0),
                 entries: [
                     { binding: 0, resource: { buffer: voxelBuffer } },
                     { binding: 1, resource: { buffer: computePassUniformsBuffer } },
                     { binding: 2, resource: { buffer: playerPosBuffer } }
                 ]
             });
             
             // 🎨 渲染绑定组 | Render bind group
             // 绑定: 体素缓冲区(只读) + 渲染参数(只读) + 工具参数(只读) + 目标位置(只读)
             // Binds: voxel buffer + render params + tool params + target position
             const renderBindGroup = device.createBindGroup({ 
                 layout: renderPipeline.getBindGroupLayout(0), 
                 entries: [ 
                     { binding: 0, resource: { buffer: voxelBuffer } }, 
                     { binding: 1, resource: { buffer: renderPassUniformsBuffer } }, 
                     { binding: 2, resource: { buffer: computePassUniformsBuffer } }, 
                     { binding: 3, resource: { buffer: targetingOutputBuffer } } 
                 ]
             });

             function resizeCanvasAndContext() {
                 const newScale = parseFloat(document.getElementById('resolutionScale').value);
                 uiControls.resolutionScale = newScale;
                 document.getElementById('resolutionScaleValue').textContent = `${(newScale * 100).toFixed(0)}%`;
                 const displayWidth = canvas.parentElement.clientWidth;
                 const displayHeight = canvas.parentElement.clientHeight;
                 const newWidth = Math.max(1, Math.floor(displayWidth * uiControls.resolutionScale));
                 const newHeight = Math.max(1, Math.floor(displayHeight * uiControls.resolutionScale));
                 if (canvas.width !== newWidth || canvas.height !== newHeight) {
                     canvas.width = newWidth;
                     canvas.height = newHeight;
                 }
             }

             function runGeneration() {
                 device.queue.writeBuffer(generationUniformsBuffer, 0, new Uint32Array([currentTerrainType]));
                 const commandEncoder = device.createCommandEncoder();
                 const genPass = commandEncoder.beginComputePass();
                 genPass.setPipeline(generationPipeline);
                 genPass.setBindGroup(0, generationBindGroup);
                 genPass.dispatchWorkgroups(VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4);
                 genPass.end();
                 device.queue.submit([commandEncoder.finish()]);
                 frameCount = 0;
             }

             runGeneration();

             document.getElementById('resetSimButton').addEventListener('click', runGeneration);
             document.getElementById('worldTypeTerrain').addEventListener('click', () => { currentTerrainType = 1; runGeneration(); document.getElementById('worldTypeTerrain').classList.add('active'); document.getElementById('worldTypeFlat').classList.remove('active'); });
             document.getElementById('worldTypeFlat').addEventListener('click', () => { currentTerrainType = 0; runGeneration(); document.getElementById('worldTypeFlat').classList.add('active'); document.getElementById('worldTypeTerrain').classList.remove('active'); });
             document.getElementById('clearLooseButton').addEventListener('click', () => {
                 const commandEncoder = device.createCommandEncoder();
                 const passClear = commandEncoder.beginComputePass();
                 passClear.setPipeline(clearLooseVoxelsPipeline);
                 passClear.setBindGroup(0, clearLooseBindGroup);
                 passClear.dispatchWorkgroups(VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4);
                 passClear.end();
                 device.queue.submit([commandEncoder.finish()]);
             });

             const toolButtonsMap = {
                 [TOOL_PAINT_SAND]: document.getElementById('toolPaintSand'),
                 [TOOL_PAINT_STONE]: document.getElementById('toolPaintStone'),
                 [TOOL_PAINT_WATER]: document.getElementById('toolPaintWater'),
                 [TOOL_DESTROY]: document.getElementById('toolDestroy')
             };
             function setActiveToolButton(tool) {
                 Object.values(toolButtonsMap).forEach(button => button.classList.remove('active'));
                 if(toolButtonsMap[tool]) toolButtonsMap[tool].classList.add('active');
             }
             Object.entries(toolButtonsMap).forEach(([toolId, buttonElement]) => {
                 buttonElement.addEventListener('click', () => {
                     currentTool = parseInt(toolId);
                     setActiveToolButton(currentTool);
                 });
             });
             setActiveToolButton(currentTool);

             document.getElementById('sunSpeed').addEventListener('input', (e) => { uiControls.sunSpeed = parseFloat(e.target.value); document.getElementById('sunSpeedValue').textContent = uiControls.sunSpeed.toFixed(4); });
             document.getElementById('brushSize').addEventListener('input', (e) => { uiControls.brushSize = parseFloat(e.target.value); document.getElementById('brushSizeValue').textContent = uiControls.brushSize.toFixed(1); });
             document.getElementById('simSteps').addEventListener('input', (e) => { uiControls.simSteps = parseInt(e.target.value); document.getElementById('simStepsValue').textContent = uiControls.simSteps.toString(); });
             document.getElementById('maxRaySteps').addEventListener('input', (e) => { uiControls.maxRaySteps = parseInt(e.target.value); document.getElementById('maxRayStepsValue').textContent = uiControls.maxRaySteps.toString(); });
             document.getElementById('continuousPaintToggle').addEventListener('change', (e) => { uiControls.continuousPaint = e.target.checked; });
             document.getElementById('targetFarFaceToggle').addEventListener('change', (e) => { uiControls.targetFarFaceOnAirHit = e.target.checked; });
             document.getElementById('resolutionScale').addEventListener('change', resizeCanvasAndContext);

             // Camera mode switching
             document.getElementById('cameraModeOrbital').addEventListener('click', () => {
                cameraMode = 'orbital';
                document.getElementById('cameraModeOrbital').classList.add('active');
                document.getElementById('cameraModeFirstPerson').classList.remove('active');
                document.getElementById('firstPersonHUD').style.display = 'none';
                document.getElementById('orbitalInstructions').style.display = 'inline';
                document.getElementById('firstPersonInstructions').style.display = 'none';
                canvas.style.cursor = 'crosshair';
                if (document.pointerLockElement === canvas) {
                   document.exitPointerLock();
                }
             });
             document.getElementById('cameraModeFirstPerson').addEventListener('click', () => {
                cameraMode = 'firstperson';
                document.getElementById('cameraModeFirstPerson').classList.add('active');
                document.getElementById('cameraModeOrbital').classList.remove('active');
                document.getElementById('firstPersonHUD').style.display = 'block';
                document.getElementById('orbitalInstructions').style.display = 'none';
                document.getElementById('firstPersonInstructions').style.display = 'inline';
                canvas.style.cursor = 'none';
             });

             // Use the specific element references from the top for these two
             const localInfoToggleButton = document.getElementById('infoToggleButton'); // This one is already setup at the top
             const localDescriptionArea = document.getElementById('descriptionArea'); // This one is already setup at the top
             // The onclick for infoToggleButton is already set up globally.

             function hideInfoPanel() { if (localDescriptionArea && !localDescriptionArea.classList.contains('hidden') && localInfoToggleButton) { localInfoToggleButton.click(); } }

             canvas.addEventListener('contextmenu', e => {e.preventDefault(); hideInfoPanel(); });
             canvas.addEventListener('mouseenter', () => isPreviewVisible = true);
             canvas.addEventListener('mouseleave', () => isPreviewVisible = false);
             
             // Keyboard controls
             window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') spacebarDown = true;
                if (cameraMode === 'firstperson') {
                   if (e.code === 'KeyW') keyState.w = true;
                   if (e.code === 'KeyA') keyState.a = true;
                   if (e.code === 'KeyS') keyState.s = true;
                   if (e.code === 'KeyD') keyState.d = true;
                   if (e.code === 'Space') { keyState.space = true; e.preventDefault(); }
                   // Shift is no longer used for movement in physics mode
                   // if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keyState.shift = true;
                }
             });
             window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') { spacebarDown = false; if (mouseState.isPanning && mouseState.buttons[0]) mouseState.isPanning = false; }
                if (cameraMode === 'firstperson') {
                   if (e.code === 'KeyW') keyState.w = false;
                   if (e.code === 'KeyA') keyState.a = false;
                   if (e.code === 'KeyS') keyState.s = false;
                   if (e.code === 'KeyD') keyState.d = false;
                   if (e.code === 'Space') keyState.space = false;
                   // Shift is no longer used for movement in physics mode
                   // if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keyState.shift = false;
                }
             });
             canvas.addEventListener('mousedown', (e) => {
                 hideInfoPanel();
                 mouseState.buttons[e.button] = true;
                 mouseState.lastX = e.clientX; mouseState.lastY = e.clientY;
                 
                 // In first-person mode, request pointer lock on click
                 if (cameraMode === 'firstperson' && document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                 }
                 
                 if (e.button === 0 && !spacebarDown && cameraMode === 'orbital') {
                     if (uiControls.continuousPaint) mouseState.isPainting = true;
                     else if (!mouseState.hasFiredSingleShot) { mouseState.isPainting = true; mouseState.hasFiredSingleShot = true; }
                     else { mouseState.isPainting = false; }
                 }
                 
                 // Paint in first-person mode
                 if (e.button === 0 && cameraMode === 'firstperson') {
                     if (uiControls.continuousPaint) mouseState.isPainting = true;
                     else if (!mouseState.hasFiredSingleShot) { mouseState.isPainting = true; mouseState.hasFiredSingleShot = true; }
                     else { mouseState.isPainting = false; }
                 }
                 
                 mouseState.isOrbiting = (e.button === 2 && cameraMode === 'orbital');
                 mouseState.isPanning = (cameraMode === 'orbital' && (e.button === 1 || (spacebarDown && e.button === 0)));
             });
             window.addEventListener('mouseup', (e) => {
                 mouseState.buttons[e.button] = false;
                 if (e.button === 0) { mouseState.isPainting = false; mouseState.hasFiredSingleShot = false; }
                 mouseState.isOrbiting = false;
                 mouseState.isPanning = false;
             });
             window.addEventListener('mousemove', (e) => {
                 if (cameraMode === 'firstperson' && document.pointerLockElement === canvas) {
                    // First-person mouse look
                    const sensitivity = 0.002;
                    firstPersonCamera.yaw -= e.movementX * sensitivity;
                    firstPersonCamera.pitch -= e.movementY * sensitivity;
                    firstPersonCamera.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, firstPersonCamera.pitch));
                 } else if (cameraMode === 'orbital') {
                    const dx = e.clientX - mouseState.lastX; const dy = e.clientY - mouseState.lastY;
                    const rect = canvas.getBoundingClientRect();
                    mouseState.x = (e.clientX - rect.left); mouseState.y = (e.clientY - rect.top);
                    if (mouseState.isOrbiting) {
                        camera.alpha -= dx * 0.005;
                        camera.beta = Math.max(-1.56, Math.min(1.56, camera.beta + dy * 0.005));
                    }
                    else if (mouseState.isPanning) {
                        camera.target[0] -= (currentRight[0]*dx - currentUp[0]*dy) * PAN_SENSITIVITY;
                        camera.target[1] -= (currentRight[1]*dx - currentUp[1]*dy) * PAN_SENSITIVITY;
                        camera.target[2] -= (currentRight[2]*dx - currentUp[2]*dy) * PAN_SENSITIVITY;
                    }
                    mouseState.lastX = e.clientX; mouseState.lastY = e.clientY;
                 }
                 
                 // Always update mouse position for cursor tracking (when not in pointer lock)
                 if (document.pointerLockElement !== canvas) {
                    const rect = canvas.getBoundingClientRect();
                    mouseState.x = (e.clientX - rect.left); mouseState.y = (e.clientY - rect.top);
                 }
             });
             canvas.addEventListener('wheel', (e) => { e.preventDefault(); camera.radius=Math.max(10, Math.min(VOXEL_GRID_SIZE*5, camera.radius+e.deltaY*0.1)); }, {passive: false});

             const resizeObserver = new ResizeObserver(entries => {
                 for (let entry of entries) { resizeCanvasAndContext(); }
             });
             if (canvas.parentElement) {
                resizeObserver.observe(canvas.parentElement);
             } else {
                 console.warn("Canvas parent element not found for ResizeObserver.");
             }
             resizeCanvasAndContext();

            // 🎮 Update first-person camera - camera bound to player voxel
            // 更新第一人称相机 - 相机绑定到玩家体素 | Update first-person camera - camera bound to player voxel
            // 玩家体素由GPU物理系统管理 | Player voxel managed by GPU physics system
            // 相机位置从玩家体素位置读取 | Camera position read from player voxel position
            function updateFirstPersonCamera(deltaTime) {
                if (cameraMode !== 'firstperson') return;
                
                // Camera movement is now handled by reading player voxel position from GPU
                // The camera follows where the player voxel falls/moves with physics
                // Only yaw and pitch are updated from mouse input (handled in mousemove event)
            }

             let lastFrameTime = performance.now();
             
             // ==================================================
             // 🎬 主渲染循环 | Main Render Loop
             // ==================================================
             // 这个函数每帧都会被调用(通常60次/秒) | This function is called every frame (typically 60 times/second)
             // 它更新物理、光照、渲染整个场景 | It updates physics, lighting, and renders the entire scene
             async function frame() {
                 // ⏱️ 计算帧时间差(deltaTime) | Calculate frame time delta (deltaTime)
                 const now = performance.now();
                 const deltaTime = (now - lastFrameTime) / 1000.0;  // 转换为秒 | Convert to seconds
                 
                 // 🎮 更新第一人称相机(如果在FPS模式) | Update first-person camera (if in FPS mode)
                 updateFirstPersonCamera(deltaTime);
                 
                 // 📷 根据相机模式计算相机位置和方向 | Calculate camera position and orientation based on mode
                 if (cameraMode === 'firstperson') {
                    // 第一人称模式: 直接使用位置和朝向 | First-person mode: use position and orientation directly
                    currentCamX = firstPersonCamera.position[0];
                    currentCamY = firstPersonCamera.position[1];
                    currentCamZ = firstPersonCamera.position[2];
                    
                    // 从yaw(水平)和pitch(垂直)角度计算前向量 | Calculate forward vector from yaw and pitch angles
                    currentForward = [
                       Math.cos(firstPersonCamera.pitch) * Math.cos(firstPersonCamera.yaw),
                       Math.sin(firstPersonCamera.pitch),
                       Math.cos(firstPersonCamera.pitch) * Math.sin(firstPersonCamera.yaw)
                    ];
                    
                    // 计算右向量(直接从yaw角度计算) | Calculate right vector (directly from yaw angle)
                    currentRight = [
                       Math.sin(firstPersonCamera.yaw),
                       0,
                       -Math.cos(firstPersonCamera.yaw)
                    ];
                    
                    // 计算上向量(叉乘) | Calculate up vector (cross product)
                    currentUp = [
                       currentForward[1] * currentRight[2] - currentForward[2] * currentRight[1],
                       currentForward[2] * currentRight[0] - currentForward[0] * currentRight[2],
                       currentForward[0] * currentRight[1] - currentForward[1] * currentRight[0]
                    ];
                    // 归一化上向量 | Normalize up vector
                    let up_n_raw = Math.hypot(...currentUp);
                    let up_n_val = up_n_raw === 0 ? 1.0 : up_n_raw;
                    currentUp = [currentUp[0]/up_n_val, currentUp[1]/up_n_val, currentUp[2]/up_n_val];
                    
                 } else {
                    // 轨道相机模式: 围绕目标点旋转 | Orbital camera mode: rotate around target point
                    // 使用球坐标转换为笛卡尔坐标 | Convert spherical coordinates to Cartesian
                    currentCamX = camera.target[0] + camera.radius * Math.cos(camera.beta) * Math.sin(camera.alpha);
                    currentCamY = camera.target[1] + camera.radius * Math.sin(camera.beta);
                    currentCamZ = camera.target[2] + camera.radius * Math.cos(camera.beta) * Math.cos(camera.alpha);

                    // 计算相机前向量(从相机指向目标) | Calculate camera forward (from camera to target)
                    const fwd_un = [camera.target[0]-currentCamX, camera.target[1]-currentCamY, camera.target[2]-currentCamZ];
                    let fwd_n_raw = Math.hypot(...fwd_un);
                    let fwd_n_val = fwd_n_raw === 0 ? 1.0 : fwd_n_raw;
                    currentForward = [fwd_un[0]/fwd_n_val, fwd_un[1]/fwd_n_val, fwd_un[2]/fwd_n_val];

                    const wUp = [0,1,0];
                    // 计算右向量 | Calculate right vector
                    currentRight = [currentForward[1]*wUp[2]-currentForward[2]*wUp[1], currentForward[2]*wUp[0]-currentForward[0]*wUp[2], currentForward[0]*wUp[1]-currentForward[1]*wUp[0]];
                    let r_n_raw = Math.hypot(...currentRight);
                    let r_n_val = r_n_raw === 0 ? 1.0 : r_n_raw;
                    currentRight = [currentRight[0]/r_n_val, currentRight[1]/r_n_val, currentRight[2]/r_n_val];

                    // 计算上向量 | Calculate up vector
                    currentUp = [currentRight[1]*currentForward[2]-currentRight[2]*currentForward[1], currentRight[2]*currentForward[0]-currentRight[0]*currentForward[2], currentRight[0]*currentForward[1]-currentRight[1]*currentForward[0]];
                    let up_n_raw = Math.hypot(...currentUp);
                    let up_n_val = up_n_raw === 0 ? 1.0 : up_n_raw;
                    currentUp = [currentUp[0]/up_n_val, currentUp[1]/up_n_val, currentUp[2]/up_n_val];
                 }

                 // ☀️ 更新太阳角度(日夜循环) | Update sun angle (day/night cycle)
                 // 🎨 可调参数: sunSpeed控制日夜循环速度 | Adjustable: sunSpeed controls day/night cycle speed
                 sunAngle += uiControls.sunSpeed * 0.2;
                 // 从角度计算太阳方向向量 | Calculate sun direction vector from angle
                 const sunDirection = [Math.cos(sunAngle), 0.707, Math.sin(sunAngle)];
                 
                 // 计算相机目标位置 | Calculate camera target position
                 const cameraTarget = cameraMode === 'firstperson' 
                    ? [currentCamX + currentForward[0], currentCamY + currentForward[1], currentCamZ + currentForward[2]]
                    : camera.target;
                 
                 // 💡 更新动态光源位置 | Update dynamic light positions
                 const lightData = new Float32Array(8 * NUM_LIGHTS);
                 for(let i = 0; i < NUM_LIGHTS; i++) {
                     // 光源向下移动 | Lights move downward
                     lights[i].position[1] += lights[i].velocity * deltaTime;
                     // 如果光源落到底部，重置到顶部 | If light falls below bottom, reset to top
                     if (lights[i].position[1] < -lights[i].radius) {
                         lights[i].position[0] = Math.random() * VOXEL_GRID_SIZE;
                         lights[i].position[1] = VOXEL_GRID_SIZE + lights[i].radius;
                         lights[i].position[2] = Math.random() * VOXEL_GRID_SIZE;
                     }
                     // 将光源数据写入Float32Array | Write light data to Float32Array
                     const offset = i * 8;
                     lightData.set(lights[i].position, offset); 
                     lightData[offset + 3] = lights[i].radius;
                     lightData.set(lights[i].color, offset + 4); 
                     lightData[offset + 7] = 1.0;  // 强度 | Intensity
                 }
                 // 📤 上传光源数据到GPU | Upload light data to GPU
                 device.queue.writeBuffer(lightsUniformBuffer, 0, lightData.buffer);
                 device.queue.writeBuffer(lightsUniformBuffer, 32 * NUM_LIGHTS, new Uint32Array([NUM_LIGHTS]));

                 // 📷 准备渲染参数并上传到GPU | Prepare render parameters and upload to GPU
                 const renderUBO = new Float32Array(renderPassUniformsBuffer.size/4);
                 const renderUBOInt = new Uint32Array(renderUBO.buffer);
                 renderUBO.set([currentCamX,currentCamY,currentCamZ], 0); 
                 renderUBO.set([2.0], 3);  // FOV/zoom
                 renderUBO.set(currentRight, 4); 
                 renderUBO.set(currentUp, 8);
                 renderUBO.set(cameraTarget, 12); 
                 renderUBO.set(sunDirection, 16); 
                 renderUBO.set([canvas.width,canvas.height], 20);
                 renderUBOInt[22] = uiControls.maxRaySteps;  // 最大光线步数 | Max ray steps
                 device.queue.writeBuffer(renderPassUniformsBuffer, 0, renderUBO);

                 // 🖥️ 准备计算参数并上传到GPU | Prepare compute parameters and upload to GPU
                 const computeUBO = new Float32Array(computePassUniformsBuffer.size/4);
                 const computeUBOInt = new Uint32Array(computeUBO.buffer);
                 computeUBO.set([currentCamX,currentCamY,currentCamZ], 0); 
                 computeUBO.set([2.0], 3); 
                 computeUBO.set(currentRight, 4); 
                 computeUBO.set(currentUp, 8);
                 computeUBO.set(cameraTarget, 12);
                 // 在第一人称模式下，始终瞄准屏幕中心 | In first-person mode, always aim at screen center
                 const mx = cameraMode === 'firstperson' ? canvas.width / 2 : mouseState.x * (canvas.width / canvas.clientWidth);
                 const my = cameraMode === 'firstperson' ? canvas.height / 2 : mouseState.y * (canvas.height / canvas.clientHeight);
                 computeUBO.set([mx, my], 16); 
                 computeUBO.set([canvas.width, canvas.height], 18); 
                 computeUBO.set([uiControls.brushSize], 20);
                 let paintingGPU = (mouseState.buttons[0] && (cameraMode === 'firstperson' || !spacebarDown)) && (uiControls.continuousPaint || mouseState.isPainting);
                 computeUBOInt[21] = paintingGPU ? 1:0;
                 computeUBOInt[22] = currentTool; 
                 computeUBOInt[23] = isPreviewVisible ? 1:0;
                 computeUBOInt[24] = uiControls.targetFarFaceOnAirHit ? 1:0;
                 computeUBOInt[25] = frameCount;
                 computeUBOInt[26] = uiControls.maxRaySteps;
                 device.queue.writeBuffer(computePassUniformsBuffer, 0, computeUBO);
                 if (!uiControls.continuousPaint && mouseState.isPainting) mouseState.isPainting = false;

                 // ==================================================
                 // 🚀 GPU命令编码和执行 | GPU Command Encoding and Execution
                 // ==================================================
                 // CommandEncoder记录要发送到GPU的命令 | CommandEncoder records commands to send to GPU
                 const commandEncoder = device.createCommandEncoder();

                 // 🎯 第1步: 目标定位通道 | Step 1: Targeting pass
                 // 使用GPU光线追踪找到鼠标指向的3D位置 | Use GPU ray tracing to find 3D position under mouse
                 const passTarget = commandEncoder.beginComputePass();
                 passTarget.setPipeline(targetingPipeline); 
                 passTarget.setBindGroup(0, targetingBindGroup);
                 passTarget.dispatchWorkgroups(1);  // 只需要1个工作组 | Only need 1 workgroup
                 passTarget.end();

                 // 🧍 第1.5步: 玩家体素管理通道(仅第一人称模式) | Step 1.5: Player voxel management pass (first-person mode only)
                 if (cameraMode === 'firstperson') {
                     // 管理玩家体素: 创建或维护玩家体素 | Manage player voxel: create or maintain player voxel
                     const passManagePlayer = commandEncoder.beginComputePass();
                     passManagePlayer.setPipeline(managePlayerPipeline);
                     passManagePlayer.setBindGroup(0, managePlayerBindGroup);
                     passManagePlayer.dispatchWorkgroups(1);  // 单线程管理 | Single thread management
                     passManagePlayer.end();
                 }

                 // ⚡ 第2步: 物理模拟通道(可能多次) | Step 2: Physics simulation pass (possibly multiple times)
                 // 🎨 可调参数: uiControls.simSteps控制每帧模拟步数 | Adjustable: simSteps controls simulation steps per frame
                 if (uiControls.simSteps > 0) {
                     for (let i = 0; i < uiControls.simSteps; i++) {
                         // 重置"已更新"标志 | Reset "updated" flags
                         const passReset = commandEncoder.beginComputePass();
                         passReset.setPipeline(resetFlagsPipeline); 
                         passReset.setBindGroup(0, resetFlagsBindGroup);
                         // dispatchWorkgroups启动GPU计算 | dispatchWorkgroups launches GPU compute
                         // 参数是工作组数量，不是线程数 | Parameters are workgroup counts, not thread counts
                         passReset.dispatchWorkgroups(VOXEL_GRID_SIZE / 8, VOXEL_GRID_SIZE / 8, VOXEL_GRID_SIZE / 4); 
                         passReset.end();

                         // 执行物理模拟 | Execute physics simulation
                         const passSim = commandEncoder.beginComputePass();
                         passSim.setPipeline(simulationPipeline); 
                         passSim.setBindGroup(0, simulationBindGroup);
                         passSim.dispatchWorkgroups(VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4); 
                         passSim.end();
                     }
                 }

                 // 🔍 第2.5步: 寻找玩家体素位置(仅第一人称模式) | Step 2.5: Find player voxel position (first-person mode only)
                 if (cameraMode === 'firstperson') {
                     // 扫描所有体素寻找玩家 | Scan all voxels to find player
                     const passFindPlayer = commandEncoder.beginComputePass();
                     passFindPlayer.setPipeline(findPlayerPipeline);
                     passFindPlayer.setBindGroup(0, findPlayerBindGroup);
                     passFindPlayer.dispatchWorkgroups(VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4, VOXEL_GRID_SIZE / 4);
                     passFindPlayer.end();
                     
                     // Copy player position to CPU-readable buffer for camera binding
                     commandEncoder.copyBufferToBuffer(playerPosBuffer, 0, playerPosReadBuffer, 0, 16);
                 }

                 // 🖌️ 第3步: 绘制工具应用 | Step 3: Paint tool application
                 if (paintingGPU) {
                     const passPaint = commandEncoder.beginComputePass();
                     passPaint.setPipeline(paintPipeline); 
                     passPaint.setBindGroup(0, paintBindGroup);
                     const d = Math.ceil(uiControls.brushSize * 2.0);
                     passPaint.dispatchWorkgroups(Math.ceil(d/4), Math.ceil(d/4), Math.ceil(d/4));
                     passPaint.end();
                 }

                 // 💡 第4步: 光照计算通道 | Step 4: Lighting calculation pass
                 const passLight = commandEncoder.beginComputePass();
                 passLight.setPipeline(lightingPipeline); 
                 passLight.setBindGroup(0, lightBindGroup);
                 passLight.dispatchWorkgroups(VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4, VOXEL_GRID_SIZE/4);
                 passLight.end();

                 // 🎨 第5步: 渲染通道 | Step 5: Render pass
                 // 这是唯一的渲染通道，将3D场景绘制到屏幕 | This is the only render pass, draws 3D scene to screen
                 const passRender = commandEncoder.beginRenderPass({ 
                     colorAttachments: [{ 
                         view: context.getCurrentTexture().createView(),  // 获取画布纹理 | Get canvas texture
                         clearValue: [0.1, 0.1, 0.2, 1.0],  // 清除颜色(深蓝色) | Clear color (dark blue)
                         loadOp: 'clear',   // 清除之前的内容 | Clear previous content
                         storeOp: 'store'   // 保存渲染结果 | Store render result
                     }] 
                 });
                 passRender.setPipeline(renderPipeline); 
                 passRender.setBindGroup(0, renderBindGroup);
                 passRender.draw(3);  // 绘制3个顶点(全屏三角形) | Draw 3 vertices (fullscreen triangle)
                 passRender.end();

                 // 🚀 提交所有命令到GPU执行 | Submit all commands to GPU for execution
                 device.queue.submit([commandEncoder.finish()]);
                 
                 // 🧍 第一人称模式：读取玩家位置并绑定相机 | First-person mode: Read player position and bind camera
                 if (cameraMode === 'firstperson') {
                     // Only start a new map operation if one is not already pending
                     // 只有在没有待处理的映射操作时才启动新的映射
                     if (!playerPosMapPending) {
                         playerPosMapPending = true;
                         // Read player position asynchronously (will be applied next frame)
                         playerPosReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
                             const data = new Uint32Array(playerPosReadBuffer.getMappedRange());
                             const playerX = data[0];
                             const playerY = data[1];
                             const playerZ = data[2];
                             const found = data[3];
                             
                             // If player voxel was found, bind camera to it
                             if (found === 1) {
                                 // Update camera position to player voxel position + eye height offset
                                 firstPersonCamera.position[0] = playerX + 0.5; // Center of voxel
                                 firstPersonCamera.position[1] = playerY + PLAYER_EYE_HEIGHT; // Eye height above voxel
                                 firstPersonCamera.position[2] = playerZ + 0.5; // Center of voxel
                             }
                             
                             playerPosReadBuffer.unmap();
                             playerPosMapPending = false; // Map operation complete
                         }).catch(err => {
                             // Silently handle mapping errors (can happen if buffer is busy)
                             console.warn("Player position readback skipped:", err);
                             playerPosMapPending = false; // Reset flag on error
                         });
                     }
                 }

                 // 📊 更新FPS显示 | Update FPS display
                 document.getElementById('fps').textContent = (1000 / (now - lastFrameTime)).toFixed(1);
                 lastFrameTime = now;
                 frameCount++;
                 
                 // 🔄 请求下一帧 | Request next frame
                 requestAnimationFrame(frame);
             }
             frame(); // 启动渲染循环 | Start the render loop
         } // End of initAndRun

         // Call the main async function and catch any errors
         initAndRun().catch(error => {
             console.error("VibeSand critical runtime failure:", error);
         });
      </script>
   </body>
</html>
